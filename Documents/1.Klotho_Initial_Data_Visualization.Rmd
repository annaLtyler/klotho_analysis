---
title: "Klotho initial data visualization"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

The purpose of this document is to get oriented with
the first RNA-Seq data to come out of the Klotho
project and with using Synapse. In this workflow we:

1. Download mouse metadata and expression data
2. Count mice in age, sex and genotype groups.
3. Bin the mice into age groups (4 and 12 months).
4. Examine expression data for batch effects
5. Normalize and scale expression data.
6. Calculate differential expression across all genotype groups using ANOVA
7. Look for enrichment of differentially expressed genes.
8. Compare expression of AD genes across Klotho genotypes
9. Look for differential expression in biodomain genes across genotypes.
10. Generate mouse gene lists for biodomains, KEGG pathways, intersections
  between GO terms and biodomains, and intersections between boidomains
  and KEGG pathways.

```{r set_version, eval = FALSE}
#IT keeps updating R automatically, which breaks all my code.
#this line points us to the original development library.
#You need to run this before you can click the knit button
#because knit calls rmarkdown::render, which is in the older 
#library
.libPaths(c("~/Library/R/arm64/4.4/library", .libPaths()))
```

```{r param}
rm(list = ls())

library(here)

#expression.type = "transcript"; id_col <- "ensembl_transcript_id"
expression.type = "gene"; id_col = "ensembl_gene_id"

min.term.size = 10 #minimum number of genes allowed in a term
fdr.thresh = 0.1 #fdr for differentially expressed genes

args <- commandArgs(trailingOnly=T)
subgroup <- args[2]

if(is.na(subgroup)){
  #subgroup <- "all ages"
  subgroup <- list("age_batch" = 12)
  #subgroup <- list("age_batch" = 4)
  #subgroup <- list("age_batch" = 4, "sex_ge" = "Female") #example with more than one filter
}

if(subgroup == "all ages"){
  results.dir <- here("Results", paste("all", expression.type, sep = "_"))
}else{
  subgroup.results <- paste(sapply(1:length(subgroup), 
    function(x) paste(names(subgroup)[x], subgroup[[x]], sep = "_")), 
    collapse = "_")
  results.dir <- here("Results", paste(subgroup.results, expression.type, sep = "_"))
}

if(!file.exists(results.dir)){
  dir.create(results.dir, TRUE)
  }

general.data.dir <- here("Data", "general")

remove.qc <- TRUE #if 1a_Klotho_QC.Rmd has been run, and animals were identified for removal
                  #set this to TRUE

ordered.geno <- c("FC/FC", "WT/FC", "WT/WT", "WT/VS", "VS/VS")

use.carrier.status <- TRUE #if true, fits models with the ordered factor FC > WT > VS
                          #if false, fits modesl with the ordered factor FC/FC > FC/WT > WT/WT > WT/VS > VS/VS
if(use.carrier.status){
  geno.used = c("FC, WT, VS"); carrier.text = "carriers"
  }else{
    geno.used = paste(ordered.geno, collapse = ", ")
    carrier.text = "all_geno"
  }

#group.representation = "eigengene" #decide whether a group of genes will be represented by 
                            #their mean expression or the first PC of their expression
                            #matrix
                            #this is giving very strange results, so I'm abandoning it for now
group.representation = "means"

```

```{r is_final}
#set flag for writing out results to a for_paper directory
#only write out results if we are using the final parameters
#we've decided on for the paper. This check can be reset when
#we decide on the final settings.

#set to TRUE. If any of the following conditions are met, 
#we are not using the final prameters.
final.params <- TRUE 

if(expression.type == "transcript"){final.params = FALSE}
if(min.term.size != 10){final.params = FALSE}
if(fdr.thresh != 0.1){final.params = FALSE}
if(length(subgroup) != 1 && subgroup[[1]] != 12){final.params = FALSE}
if(!remove.qc){final.params = FALSE}
if(!use.carrier.status){final.params = FALSE} #if true, fits models with the ordered factor FC > WT > VS
if(group.representation != "means"){final.params = FALSE}

if(final.params){
  final.text <- "This IS the final set of parameters for the paper."
}else{
  final.text <- "This IS NOT not the final set of parameters for the paper."
}
```

## Paramters set

This workflow used the following parameters:

Subgroup: `r paste(names(subgroup), subgroup, sep = " = ")`

Genotypes analyzed: `r geno.used`

Units of expression: `r expression.type`

Minimum number of genes in a group: `r min.term.size`

FDR threshold for significance: `r fdr.thresh`

`r final.text`

```{r load_code}
all.fun <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.fun)){source(all.fun[i])}

processed.data.dir <- file.path(results.dir, "processed_data")
if(!file.exists(processed.data.dir)){dir.create(processed.data.dir, recursive = TRUE)}

general.processed.data.dir <- here("Results", "Processed_Data")
if(!file.exists(general.processed.data.dir)){dir.create(general.processed.data.dir)}

geno.cols <- get_geno_cols(here("Data", "general", "geno_cols.csv"))
```

```{r libraries, message = FALSE, warning = FALSE, error = FALSE}
needed.libraries <- c("pheatmap", "DESeq2", "DT", "vioplot", "RColorBrewer",
  "gprofiler2", "cluster", "pathview", "clusterProfiler", "stringr", "igraph", "wordcloud",
  "wordcloud2")
load_libraries(needed.libraries)
```

```{r info}
kl.ensembl <- "ENSMUSG00000058488"

#gene information tables
mouse.gene.table <- read.table(file.path(general.data.dir, "mouse_gene_info.txt"), sep = "\t", header = TRUE)
orthos <- read.table(file.path(general.data.dir, "human.mouse.orthologs.txt"), sep = "\t", header = TRUE)
```


```{r download_data, error = FALSE, message = FALSE, warning = FALSE}
data_id <- read.table(here("Data", "Synspse_IDs_Klotho.txt")) #made by hand by copying and pasting file names and IDs from Synapse web page
mouse.data.dir <- here("Data", "Mouse")
human.data.dir <- here("Data", "Human")
if(!file.exists(mouse.data.dir)){dir.create(mouse.data.dir)}

file.dest <- file.path(mouse.data.dir, data_id[,1])
need.to.download <- any(!file.exists(file.dest))

if(need.to.download){
  synLogin()
  logged.in <- TRUE

  for(i in 1:length(file.dest)){
    
    if(!file.exists(file.dest[i])){
      synGet(data_id[i,2], downloadLocation = mouse.data.dir)
    }
  }
}
```

```{r load_metadata}
mouse.info <- read.csv(file.path(mouse.data.dir, "metadata_validated.csv"))
orthos <- read.delim(file.path(general.data.dir, "human.mouse.orthologs.txt"))
```

```{r count_data}
if(expression.type == "transcript"){
  count.data <- read.delim(file.path(mouse.data.dir, "rsem.merged.transcript_counts.tsv"))
}else{
  count.data <- read.delim(file.path(mouse.data.dir, "rsem.merged.gene_counts.tsv"))
}
```

```{r split_ind}
u_id <- unique(mouse.info[,"animalName"])
ind.tables <- lapply(u_id, function(x) mouse.info[which(mouse.info[,"animalName"] == x),])
```

```{r condense}
#This function takes all the information on a single individual and condenses
#it into a more readable format. Each individual has two lines in the table
#one each for the two KL haplotypes. The two lines tell us the genotype.
#we go by the sequenced genotype not by what is in Climb because that is
#more reliable. 
#for each of these haplotypes separately.
condense_geno <- function(call, allele){
  if(is.na(call)){
    return("Inconclusive")
  }
  if(call == "WT"){
    cond.geno <- "WT/WT"
  }
  if(call == "Homozygous"){
    cond.geno <- paste0(allele, "/", allele)
  }
  if(call == "Heterozygous"){
    cond.geno <- paste0("WT/", allele)
  }
  return(cond.geno)
}

merge.geno <- function(fc.geno, vs.geno){
  #if both are wild type
  u_geno <- unique(c(fc.geno, vs.geno))
  if(any(is.na(u_geno))){
    return("Inconclusive")
  }
  if(any(u_geno == "Inconclusive")){
    return("Inconclusive")
  }
  if(length(u_geno) == 1){
    final.geno <- u_geno
  }else{
    not.wt <- which(u_geno != "WT/WT")
    if(length(not.wt) == 1){
      final.geno <- u_geno[not.wt]
    }else{
      final.geno <- "FC/VS"
    }
  }
  return(final.geno)
}


condense_info <- function(individ.table){
  vs.idx <- which(individ.table[,"snp"] == "Klotho-VS")
  fc.idx <- which(individ.table[,"snp"] == "Klotho-FC")
  vs.seq <- condense_geno(call = individ.table[vs.idx,"genotype_seq"], allele = "VS")
  fc.seq <- condense_geno(individ.table[fc.idx,"genotype_seq"], "FC")
  seq.geno <- merge.geno(fc.seq, vs.seq)

  vs.climb <- condense_geno(call = individ.table[vs.idx,"genotype_climb"], allele = "VS")
  fc.climb <- condense_geno(individ.table[fc.idx,"genotype_climb"], "FC")
  climb.geno <- merge.geno(fc.climb, vs.climb)

  #dont.include <- c("genotype_climb", "genotype_seq", "snp", "validated.gt", "line")
  dont.include <- c("genotype_climb", "genotype_seq", "snp", "line")
  include <- setdiff(colnames(individ.table), dont.include)
  final.info <- unlist(c(individ.table[1,include], "seq_genotype" = seq.geno, "climb_geno" = climb.geno))
  return(final.info)
}

condensed.table <- t(sapply(ind.tables, condense_info))
#head(condensed.table)
```

```{r qc}
#one mouse was labeled as 24 months, but it should be 12 months (talked with Dylan Garceau)
#change this by hand

wrong.age <- which(condensed.table[,"age_m"] == 24)
condensed.table[wrong.age,"age_m"] <- 12

#remove animals identified in 1a_Klotho_QC.Rmd
if(remove.qc){
  #remove animals identified by 1a_Klotho_QC.Rmd
  qc.id <- read.table(here("Data", "general", "ID_QC.txt"), header = TRUE)
  for(i in 1:nrow(qc.id)){
    mouse.id <- qc.id[i,1]
    action <- qc.id[i,2]
    mouse.idx <- which(condensed.table[,"animalName"] == mouse.id)
    if(action == "remove"){
      condensed.table <- condensed.table[-mouse.idx,]
    }else{
      condensed.table[mouse.idx,"sex_climb"] <- action
    }
  }
}

#intersect(qc.id[,1], condensed.table[,"animalName"])
```


The table of animals with called genotypes is as follows:

```{r dt}
datatable(condensed.table)
write.table(condensed.table, file.path(results.dir, "mouse.info.csv"), sep = ",", quote = FALSE)
```

## Group Counts

The tables below show the numbers of animals in each group.
The x axis in each panel shows the age of the mice in months.
The y axis shows each included genotype.

The largest group right now is 12-month-old WT mice. There
are no FC/VS mice yet. 


```{r kl_types}
sexes <- unique(condensed.table[,"sex_ge"]) #use the sequenced sex
ages <- sort(as.numeric(unique(condensed.table[,"age_m"])))
genotypes <- unique(condensed.table[,"climb_geno"])[c(2,5,4,1,3,6)]

#build a separate table for each allele and sex and count the
#mice in each age group.
count.tables <- vector(mode = "list", length = length(sexes))
names(count.tables) <- sexes
for(s in 1:length(sexes)){
    sex.idx <- which(condensed.table[,"sex_climb"] == sexes[s])
    by.age <- matrix(0, nrow = length(genotypes), ncol = length(ages))
    rownames(by.age) <- genotypes
    colnames(by.age) <- ages
    for(g in 1:length(genotypes)){
      genotype.idx <- grep(genotypes[g], condensed.table[,"climb_geno"])
      for(ag in 1:length(ages)){
        age.idx <- which(condensed.table[,"age_m"] == ages[ag])
        num.in.group <- length(Reduce("intersect", list(sex.idx, genotype.idx, age.idx)))
        by.age[g,ag] <- num.in.group
      }
    }
    count.tables[[s]]  <- by.age
}
```

```{r plot_counts, fig.width = 9, fig.height = 4}
#quartz(width = 9, height = 3)
par(mfrow = c(1,2), mar = c(2,8,4,2))
for(s in 1:length(sexes)){
  imageWithText(count.tables[[s]], use.pheatmap.colors = TRUE,
    main = sexes[s], cex = 1, main.shift = 0.15, row.text.shift = 0.1,
    col.text.rotation = 0, col.text.shift = 0.15, col.text.adj = 0.5)
}
```

```{r remove_inc}
inc.idx <- which(condensed.table[,"climb_geno"] == "Inconclusive")
if(length(inc.idx) > 0){
  condensed.table <- condensed.table[-inc.idx,,drop=FALSE]
}
```

We removed `r length(inc.idx)` entries with inconclusive genotypes.

### Bin ages

The age groups are 4 and 12 months so far. Twenty-four months
will be coming later. Here we bin the animals into those age
groups.

```{r bin_age}
age.groups <- c(4, 12, 24)
age.diff <- lapply(age.groups, function(x) abs(x-as.numeric(condensed.table[,"age_m"])))
age.which <- lapply(age.diff, function(x) which(x <= 1))
age.batch <- rep(NA, nrow(condensed.table))
for(i in 1:length(age.which)){
  age.batch[age.which[[i]]] <- age.groups[i]
}
condensed.table <- cbind(condensed.table, "age_batch" = age.batch)
```

```{r recount_groups}
sexes <- unique(condensed.table[,"sex_ge"])
ages <- sort(as.numeric(unique(condensed.table[,"age_batch"])))
genotypes <- unique(condensed.table[,"climb_geno"])[c(2,5,4,1,3,6)]

#build a separate table for each allele and sex and count the
#mice in each age group.
count.tables <- vector(mode = "list", length = length(sexes))
names(count.tables) <- sexes
for(s in 1:length(sexes)){
    sex.idx <- which(condensed.table[,"sex_climb"] == sexes[s])
    by.age <- matrix(0, nrow = length(genotypes), ncol = length(ages))
    rownames(by.age) <- genotypes
    colnames(by.age) <- ages
    for(g in 1:length(genotypes)){
      genotype.idx <- grep(genotypes[g], condensed.table[,"climb_geno"])
      for(ag in 1:length(ages)){
        age.idx <- which(condensed.table[,"age_m"] == ages[ag])
        num.in.group <- length(Reduce("intersect", list(sex.idx, genotype.idx, age.idx)))
        by.age[g,ag] <- num.in.group
      }
    }
    count.tables[[s]]  <- by.age
}

full.count.table <- Reduce("cbind", count.tables)
colnames(full.count.table) <- paste(rep(names(count.tables), 
  each = length(count.tables)), colnames(full.count.table), sep = "_")
keep.rows <- which(!is.na(row.names(full.count.table)))

if(final.params){
  write.table(full.count.table[keep.rows,], 
    here("Results", "for_paper", "mouse_count_table.txt"), sep = "\t",
    quote = FALSE)
}
```

The following grid shows how many animals are in each 
age batch. We will use the age batch as a covariate 
going forward.

```{r plot_counts2, fig.width = 8, fig.height = 4}
#quartz(width = 8, height = 4)
par(mfrow = c(1,2), mar = c(2,8,4,2))
for(s in 1:length(sexes)){
  imageWithText(count.tables[[s]], use.pheatmap.colors = TRUE,
    main = sexes[s], cex = 1, main.shift = 0.15, row.text.shift = 0.55,
    col.text.rotation = 0, col.text.shift = 0.15, col.text.adj = 0.5)
}
```


## Select Subgroup
If there is a subgroup analysis specified in the parameter
section, we select that here.

```{r select_subgroup}
if(subgroup != "all ages"){
  sub.idx <- Reduce("intersect", lapply(1:length(subgroup), 
    function(x) which(condensed.table[,names(subgroup)[x]] == subgroup[[x]])))
  #overwrite condensed.table
  if(length(sub.idx))
  full.table <- condensed.table
  condensed.table <- condensed.table[sub.idx,]
}
```

## Transcript Data

Here we use transcript count data. These data were generated 
by Annat Haber and Catrina Spruce. The details of the 
analysis can be found on Synapse with ID syn52749871.

```{r process_counts}
count.num <- as.matrix(count.data[,3:ncol(count.data)])
count.id <- as.matrix(count.data[,1:2])
rownames(count.num) <- count.id[,1] #name using transcript IDs
colnames(count.num) <- gsub("X", "", colnames(count.num))

#make sure mouse IDs are aligned across the information table
#and data table.
included.idx <- match(condensed.table[,1], colnames(count.num))
#cbind(colnames(count.num)[included.idx], condensed.table[,1])
sub.count <- count.num[,included.idx]
```

```{r check_counts, eval = FALSE}
gene.name <- "Srsf5"
#gene.name <- "Apoe"
gene.id <- mouse.gene.table[which(mouse.gene.table[,"external_gene_name"] == gene.name), "ensembl_gene_id"]
gene.idx <- which(rownames(sub.count) == gene.id)
gene.counts <- sub.count[gene.idx,]
hist(log10(as.vector(sub.count)), main = paste("All log10 counts with", gene.name, "marked"),
  xlab = "log10 count")
abline(v = mean(log10(gene.counts)), col = "red")
vioplot(log10(gene.counts)~as.factor(condensed.table[,"climb_geno"]), col = geno.cols, 
  xlab = "", main = gene.name, ylab = "log10 gene count")
test <- lm(log10(gene.counts)~as.factor(condensed.table[,"climb_geno"]))
anova(test)[,"Pr(>F)"][1]
```

Use DESeq2 to filter out low-expressing genes and to normalize.
We use the vst normalization. 

```{r normalize_filter}

#add genotype based on whether we are looking at all genotypes or carrier status
if(use.carrier.status){
  carrier.factor <- rep("WT", nrow(condensed.table))
  carrier.factor[grep("VS", condensed.table[,"climb_geno"])] <- "VS"
  carrier.factor[grep("FC", condensed.table[,"climb_geno"])] <- "FC"
  geno_factor <- ordered(carrier.factor, levels = c("FC", "WT", "VS"))
  sub.cols <- c(geno.cols["FC/FC"], geno.cols["WT/WT"], geno.cols["VS/VS"])
  names(sub.cols) <- c("FC", "WT", "VS")
  geno.cols <- sub.cols
}else{
  geno_factor <- ordered(condensed.table[,"climb_geno"], levels = ordered.geno)
}

#treat everything as a factor
info <- data.frame("sequencingBatch" = as.factor(condensed.table[,"sequencingBatch"]),
  "sex_ge" = as.factor(condensed.table[,"sex_ge"]),
  "age_batch" = ordered(condensed.table[,"age_batch"], levels = c("4", "12")),
  "ordered_geno" = geno_factor) 
rownames(info) <- condensed.table[,"animalName"]
write.table(info, file.path(processed.data.dir, 
  paste0("mouse_info_", carrier.text, ".csv")), sep = ",", row.names = TRUE)

# Create design matrices: Include both the condition of interest and the batch variable.
# Assuming 'genotype' is your condition and 'sequencingBatch' is the batch factor
# age_m and sex_ge are potential covariates

possible.covar <- c("sequencingBatch", "sex_ge", "age_batch", "ordered_geno")
#possible.covar <- c("sequencingBatch")
use.covar <- setdiff(possible.covar, names(subgroup))
fmla <- as.formula(paste0("~", paste(use.covar, collapse = " + ")))
design.genotype <- model.matrix(fmla, data=info)

#I tested putting different variables as the "group" variable, 
#and all normalizations were identical.
dds <- DESeqDataSetFromMatrix(round(sub.count), colData = info, design = design.genotype)
#nrow(dds)

smallestGroupSize <- 4
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]
#nrow(dds)

sub.id <- count.id[keep,]
vsd <- vst(dds, blind = FALSE)
```



```{r transcript_info}
#gather information about transcripts in filtered data set
if(expression.type == "transcript"){
  gene.info.file <- file.path(general.data.dir, "mouse_transcript_info.txt")

  if(!file.exists(gene.info.file)){
    library(biomaRt)
    all.var <- ls()

    lib.loaded <- as.logical(length(which(all.var == "mus")))
    if(!lib.loaded){
        mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") 
        #att <- listAttributes(mus)
        #fil <- listFilters(mus)
        #head(att[grep("transcript", att[,1], ignore.case = TRUE),])
        }
    
    gene.info <- getBM(c("ensembl_transcript_id", "ensembl_gene_id", 
      "external_gene_name", "entrezgene_id", "chromosome_name", 
      "transcript_start", "transcript_end", "transcript_length",
      "transcript_is_canonical"), "ensembl_transcript_id", sub.id[,1], mus)
    write.table(gene.info, gene.info.file, quote = FALSE, row.names = FALSE, sep = "\t")
    }else{
    gene.info <- read.delim(gene.info.file)
    }
}

if(expression.type == "gene"){
  gene.info.file <- file.path(general.data.dir, "mouse_gene_info.txt")
  
  if(!file.exists(gene.info.file)){
    library(biomaRt)
    all.var <- ls()

    lib.loaded <- as.logical(length(which(all.var == "mus")))
    if(!lib.loaded){
        mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") 
        #att <- listAttributes(mus)
        #fil <- listFilters(mus)
        #head(att[grep("transcript", att[,1], ignore.case = TRUE),])
        }
    
    gene.info <- getBM(c("ensembl_gene_id", "external_gene_name", "entrezgene_id", "chromosome_name", 
      "start_position", "end_position"), "ensembl_gene_id", sub.id[,1], mus)
    write.table(gene.info, gene.info.file, quote = FALSE, row.names = FALSE, sep = "\t")
    }else{
    gene.info <- read.delim(gene.info.file)
    }
}
```

Add Ide gene expression to the covariates. A variant was recently
discovered in the B6 mouse population that greatly affects gene 
expression. If this variant is present in our population, it 
could affect the traits we are measuring here. To address this 
possibility, we added Ide expression as a covariate.

```{r covar_mat}

#make a data frame with relevant covariate and group data.
#we are adding Ide expression because of a newly discovered
#variant in B6 animals that affects Ide expression.
gene.id <- gene.info[which(gene.info[,"external_gene_name"] == "Ide"), id_col]
gene.idx <- which(rownames(sub.count) %in% gene.id[1]) #use the first transcript. This is the only one expressed at reasonably high levels
gene.counts <- sub.count[gene.idx,]
#boxplot(log(t(gene.counts+1)))
scaled.counts <- scale(gene.counts)
ordered.scaled <- scaled.counts[match(rownames(scaled.counts), rownames(info))]
#hist(ordered.scaled, breaks = 25)

info$scaled_Ide_expression <- ordered.scaled
covar.mat <- info
write.table(covar.mat, file.path(processed.data.dir, 
  paste0("covariates_", carrier.text, ".csv")), sep = ",", quote = FALSE)
```


```{r pathview}
#get kegg data now for use later

mouse.kegg.file <- file.path(general.data.dir, "KEGG.Mouse.RDS")
if(!file.exists(mouse.kegg.file)){
    all.mouse.kegg <- download_KEGG("mmu", "KEGG", "kegg")
    saveRDS(all.mouse.kegg, mouse.kegg.file)
}else{
    all.mouse.kegg <- readRDS(mouse.kegg.file)
}

human.kegg.file <- file.path(general.data.dir, "KEGG.Human.RDS")
if(!file.exists(human.kegg.file)){
    all.human.kegg <- download_KEGG("hsa", "KEGG", "kegg")
    saveRDS(all.human.kegg, human.kegg.file)
}else{
    all.human.kegg <- readRDS(human.kegg.file)
}


#convert mouse entrez IDs to ensembl IDs
u_path <- gsub(" - Mus musculus (house mouse)", "", all.mouse.kegg[[2]][,"to"], fixed = TRUE)

path.id <- all.mouse.kegg[[2]][,1]
path.idx <- lapply(path.id, function(x) which(all.mouse.kegg[[1]][,1] == unlist(x)[1]))
path.gene.id <- lapply(path.idx, function(x) all.mouse.kegg[[1]][x,2])
names(path.gene.id) <- u_path

mouse.path.ensembl.file <- file.path(general.processed.data.dir, 
  paste0("Mouse_KEGG_", expression.type, "_for_GSEA.RDS"))

mouse.path.gene.ensembl <- lapply(path.gene.id, 
    function(x) mouse.gene.table[match(as.numeric(x), mouse.gene.table[,"entrezgene_id"]), "ensembl_gene_id"])
if(expression.type == "transcript"){
  gene.idx <- lapply(mouse.path.gene.ensembl, function(x) match(x[which(!is.na(x))], gene.info[,"ensembl_gene_id"]))
  mouse.path.gene.ensembl <- lapply(gene.idx, function(x) gene.info[x,id_col])
}
saveRDS(mouse.path.gene.ensembl, mouse.path.ensembl.file)


#convert human entrez IDs to ensembl IDs
u_path <- all.human.kegg[[2]][,"to"]
path.id <- all.human.kegg[[2]][,1]
path.idx <- lapply(path.id, function(x) which(all.human.kegg[[1]][,1] == unlist(x)[1]))
path.gene.id <- lapply(path.idx, function(x) all.human.kegg[[1]][x,2])
names(path.gene.id) <- u_path

#use the ortholog table to convert. We only care about genes
#that have mouse orthologs anyway (I think).
hum.path.gene.ensembl <- lapply(path.gene.id, 
    function(x) orthos[match(x, orthos[,"Human.Entrez"]), "Human.Ensembl"])

saveRDS(hum.path.gene.ensembl, file.path(general.processed.data.dir, "Human_KEGG_for_GSEA.RDS"))
```


## Batch Effects {.tabset .tabset-fade .tabset-pills}

We looked at the relationships between the first
four PCs of the normalized gene expression matrix 
and relevant variables. The plots are big, so these
are printed to pdfs in the results folder.

```{r top_alpha}
top.var.alpha.thresh <- 0.05
```

Depending on how many of the top variable genes we use, 
the factors are correlated with different PCs. Here we
use all genes for which the model explaining expression 
has a p value less than `r top.var.alpha.thresh`.


```{r pc_fun}
#top genes can be a number specifying how many of the most 
#variable genes to use in the decomposition.
#gene.names can be used to specify specific genes to be
#used. This can help in identifying sample swaps in QC

plot_pc_factors <- function(expr.mat, factors, n.pc = 4, top.genes = NULL,
  highlight.ind = NULL, highlight.col = "blue"){
  
  if(!is.data.frame(factors)){stop("factors must be a data frame.")}
  
  main.text <- ""

  if(!is.null(top.genes)){
    gene.var <- apply(expr.mat, 2, var)
    sorted.var <- sort(gene.var, decreasing = TRUE)[1:top.genes]
    expr.mat <- expr.mat[,names(sorted.var)]
    main.text <- paste("\n", top.genes, "most variable genes")
  }

  expr.decomp <- plot.decomp(expr.mat, pc = n.pc, plot.results = FALSE)
  pc.var.exp <- signif(expr.decomp$var.exp*100, 2)[1:n.pc]

  pc.pairs <- pair.matrix(1:n.pc)
  pc.factor.cor <- matrix(ncol = n.pc, nrow = ncol(factors))
  colnames(pc.factor.cor) <- paste0("PC", 1:n.pc)
  rownames(pc.factor.cor) <- colnames(factors)

  #for each factor, plot out the pairs of PCs and individual PCs
  for(i in 1:ncol(factors)){
    
    if(length(unique(factors[,i])) < 2){next()} #don't run any invariant factors

    cat("###", colnames(factors)[i], "\n")

    n.levels <- length(levels(factors[,i]))
    if(n.levels > 0){ #we have a factor
      #set default color scheme
      factor.names <- levels(as.factor(factors[,i]))
      factor.cols <- categorical_pal(8)[1:length(factor.names)]
      names(factor.cols) <- factor.names

      #if we are looking at genotype, use the specified genotype colors
      if(colnames(factors)[i] == "ordered_geno"){
        factor.cols <- geno.cols
        factor.names <- names(factor.cols)
      }

      #assign colors to individual animals based on the factor they belong to
      gcol <- rep(NA, nrow(factors))
      for(g in 1:length(factor.cols)){
        gcol[which(factors[,i] == names(factor.cols)[g])]  <- factor.cols[g]
      }
    }else{ #otherwise we have a number. Assign numerical colors
      factor.cols = colors.from.values(factors[,i], split.at.vals = TRUE, 
        col.scale = c("blue", "brown"), grad.dir = "ends")
      gcol <- factor.cols
    }

    #if we are highlighting individuals, change their color here    
    if(!is.null(highlight.ind)){
      ind.idx <- which(rownames(expr.mat) %in% highlight.ind)
      gcol[ind.idx] <- highlight.col
      factor.names <- NULL
    }

    if(i < ncol(factors)){
      layout.mat <- get.layout.mat(nrow(pc.pairs)+n.pc+2)
    }else{
      layout.mat <- get.layout.mat(nrow(pc.pairs)+n.pc+3)
    }
    layout(layout.mat)

    par(mar = c(4,4,4,2))
    for(p in 1:nrow(pc.pairs)){
      pc1 <- pc.pairs[p,1]
      pc1.var <- pc.var.exp[pc1]
      pc2 <- pc.pairs[p,2]
      pc2.var <- pc.var.exp[pc2]
      if(is.factor(factors[,i])){
        plot(expr.decomp$u[,pc1], expr.decomp$u[,pc2], pch = 16, xlab = paste0("PC", pc1, " (", pc1.var, "%)"),
          ylab = paste0("PC", pc2,  " (", pc2.var, "%)"), col = gcol,
          main = paste(colnames(factors)[i], main.text))
      }else{
        plot(expr.decomp$u[,pc1], expr.decomp$u[,pc2], pch = 16, 
          xlab = paste0("PC", pc1, " (", pc1.var, "%)"),
          ylab = paste0("PC", pc2,  " (", pc2.var, "%)"), col = gcol, 
          main = paste(colnames(factors)[i], main.text))
      }
    }
    
    #add barplots
    for(p in 1:n.pc){
      if(length(levels(as.factor(factors[,i]))) > 1){
        model <- lm(expr.decomp$u[,p]~factors[,i])
        pc.factor.cor[i,p] <- summary(model)$adj.r.squared
      }
      
      pc.order <- order(expr.decomp$u[,p])
      
        barplot(expr.decomp$u[pc.order,p],
          col = gcol[pc.order],
          main = paste("PC", p, "\n", colnames(factors)[i], main.text), border = NA)
          #factors[pc.order[intersect(which(expr.decomp$u[pc.order,p] < 0), which(gcol[pc.order] == "black"))],]
          #factors[pc.order[intersect(which(expr.decomp$u[pc.order,p] > 0), which(gcol[pc.order] != "black"))],]

        #find mis-matches
        #not.neg <- intersect(which(expr.decomp$u[,1] < 0), which(gcol == "#CE5C6D"))
        #rownames(expr.mat)[not.neg]
        #not.pos <- intersect(which(expr.decomp$u[,1] > 0), which(gcol == "black"))
        #rownames(expr.mat)[not.pos]
    }

    if(!is.null(factor.names)){
      #add legend    
      par(mar = c(0,0,2,2))
      plot.new()
      plot.window(xlim = c(0,1), ylim = c(0,1))
      legend(0, 1, legend = factor.names, pch = 16, col = factor.cols)
    }else{
      par(mar = c(4,5,2,5))
      imageWithTextColorbar(matrix(factors[,i], ncol = 1), split.at.vals = TRUE, 
        col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1)
    }
    

    #show correlate each PC with each factor
    par(mar = c(4,4,2,2))
    if(!all(is.na(pc.factor.cor[i,]))){
      a <- barplot(abs(pc.factor.cor[i,]), ylab = "Adjusted R^2", 
        main = paste0("Adjusted R^2"), ylim = c(0,1),
        names = paste0("PC", 1:n.pc, "\n", pc.var.exp, "%"))
      text(a, abs(pc.factor.cor[i,])+0.04, labels = signif(abs(pc.factor.cor[i,]), 2))
      #text(a, rep(0.04, length(a)), labels = paste(signif(pc.var.exp, 2), "%"))
    }

    cat("\n\n")
  
    if(i == ncol(factors)){
      par(mar = c(6,8,6,2))
      scaled.factor.f <- t(apply(abs(pc.factor.cor), 1, function(x) x/max(x)))
      imageWithText(signif(scaled.factor.f, 2), use.pheatmap.colors = TRUE, col.text.rotation = 0,
        col.text.adj = 0.5, col.text.shift = 0.2, row.text.shift = 0.2, main.shift = 0.2,
        main = "PC-Factor Correlations")
    }
  }
}
```

We fit a model to explain the expression of each gene with 
sequencing batch, sex, age, and genotype. We selected all
genes that had a nominally significant p value 
(p < `r top.var.alpha.thresh`) for the entire model. 

```{r post_norm_pc, fig.width = 8, fig.height = 5, results = "asis"}

#test genes for variability based on any of the possible causal factors
#then filter for the genes that vary by these, not just variable genes
#in general

expr <- assay(vsd)

if(subgroup == "all ages"){
  models <- apply(expr, 1, function(x) lm(x~sequencingBatch+sex_ge+age_batch+scaled_Ide_expression+ordered_geno, data = covar.mat))
}else{
  models <- apply(expr, 1, function(x) lm(x~sequencingBatch+sex_ge+scaled_Ide_expression+ordered_geno, data = covar.mat))
}
model.f <- lapply(models, function(x) summary(x)$fstatistic)
model.p <- sapply(model.f, function(f) pf(f[1],f[2],f[3],lower.tail=F))
#qqunif.plot(model.p)
#big.p <- which(-log10(model.p) > 10)
sig.idx <- which(model.p < top.var.alpha.thresh)
#length(sig.idx)

#checked to see if VS/FC carrier status was better represented in the PCs
#It is not
#carrier.status <- rep("WT", nrow(covar.mat))
#carrier.status[grep("VS", covar.mat[,"climb_geno"])] <- "VS"
#carrier.status[grep("FC", covar.mat[,"climb_geno"])] <- "FC"
#covar.mat <- cbind(covar.mat, "carrier.status" = as.factor(carrier.status))

pdf(file.path(results.dir, 
  paste0("PCs_and_factors_pval_less_than_", top.var.alpha.thresh, "_", 
    carrier.text, ".pdf")), width = 12, height = 8)
plot_pc_factors(expr.mat = t(expr[sig.idx,]), factors = covar.mat, n.pc = 4)
dev.off()
```

## Variance explained by genotype

If we have selected to analyze all ages, the plot below shows how well
genotype explains variation in PC1 of the transcription matrix at 
different ages.

```{r age_int, fig.width = 10, fig.height = 5}

if(subgroup == "all ages"){
  expr.decomp <- plot.decomp(t(expr[sig.idx,]), plot.results = FALSE)
  model <- lm(expr.decomp$u[,1]~ordered_geno*age_batch, data = covar.mat)
  ylim <- c(min(expr.decomp$u[,1]), max(expr.decomp$u[,1]))

  geno <- covar.mat[,"ordered_geno"]
  age <- covar.mat[,"age_batch"]

  u_age <- unique(age)

  #quartz(width = 10, height = 5)
  par(mfrow = c(1,2), mar = c(6,4,4,2))
  for(a in 1:length(u_age)){
    age.idx <- which(age == u_age[a])
    age.geno <- geno[age.idx]
    age.pc <- expr.decomp$u[age.idx,1]
    age.geno.pc <- lapply(names(geno.cols), function(x) age.pc[which(age.geno == x)])
    age.model <- lm(age.pc~as.factor(age.geno))
    age.r2 <- summary(age.model)$adj.r.squared
    age.f <- summary(age.model)$fstatistic
    age.p <- pf(age.f[1], age.f[2], age.f[3],lower.tail=F)
    boxplot(age.geno.pc, names = names(geno.cols), col = geno.cols, ylab = "PC1",
      main = paste0("PC1 by genotype at ", u_age[a], " months\nR2 = ", 
      signif(age.r2, 2), "; p = ", signif(age.p, 2)), ylim = ylim) 
    abline(h = 0)
  }
}
```

This yielded `r length(sig.idx)` genes. We used this subset
of genes in the PC plots to see which factors contributed to 
overall variation in gene expression.

## Klotho variation {.tabset .tabset-fade .tabset-pills}

The following plots show how Klotho expression varies
with age, sex, and genotype. There isn't much variation
in Klotho transcription in these animals. That's probably
fine. The Klotho variants we are dealing with are coding
variants and probably don't have any effect on gene 
expression.

```{r klotho, fig.width = 4, fig.height = 4}

norm.expr <- assay(vsd)
saveRDS(norm.expr, file.path(processed.data.dir, 
  paste0("Normalized_Expression_", carrier.text, ".RDS")))

#scale expression across individuals
scaled.expr <- t(apply(norm.expr, 1, scale))
dimnames(scaled.expr) <- dimnames(norm.expr)
saveRDS(scaled.expr, file.path(processed.data.dir, 
  paste0("Scaled_Expression_", carrier.text, ".RDS")))

if(expression.type == "transcript"){
  tx.id <- sub.id[which(sub.id[,"gene_id"] == kl.ensembl),"transcript_id"]  
}else{
  tx.id <- sub.id[which(sub.id[,"gene_id"] == kl.ensembl),"gene_id"]  
}
tx.name <- paste("Klotho transcript", 1:length(tx.id))

kl.levels <- scaled.expr[tx.id,,drop=FALSE]

if(expression.type == "transcript"){
  plot.with.model(kl.levels[1,], kl.levels[2,], xlab = "Kl transcript 1",
  ylab = "Kl transcript 2", main = "Correlation of Kl transcripts")
}

plot_tx_with_factor <- function(expr.mat, covar.table, tx_name, factor_name, 
  ylab = "Count", tx_label = "Transcript", pt_col = "#c51b8a", cex.labels = 1){
    
    #make a dummy matrix to adjust expression 
    factor.idx <- which(colnames(covar.table) == factor_name)
    is_numeric <- which(sapply(1:ncol(covar.table), function(x) length(levels(covar.table[,x]))) == 0)

    #dummy_covar will convert anything that is a factor to a dummy
    dummy.mat <- dummy_covar(covar.table[,-c(factor.idx)])
    #tack on any numeric covariates
    if(length(is_numeric) > 0){
      dummy.mat <- as.matrix(cbind(dummy.mat, covar.mat[,is_numeric,drop=FALSE]))
    }


  for(i in 1:length(tx_name)){

    if(is.factor(covar.mat[,factor_name])){
      model <- lm(expr.mat[tx_name[i],]~covar.table[,factor_name])
      model.p <- signif(anova(model)$"Pr(>F)"[1], 2)
      vioplot(expr.mat[tx_name[i],]~covar.table[,factor_name], xlab = "", 
        main = paste(tx_label[i], "\np =", model.p), col = "lightgray",
        cex.names = cex.labels, cex.axis = cex.labels, ylab = "")
      mtext(ylab, side = 2, line = 2.5, cex = cex.labels)
      stripchart(expr.mat[tx_name[i],]~covar.table[,factor_name], 
        col = pt_col, vertical = TRUE, pch = 16, method = "jitter", add = TRUE)
    }
    if(is.numeric(covar.mat[,factor_name])){
      model <- lm(expr.mat[tx_name[i],]~as.numeric(covar.table[,factor_name]))
      model.p <- signif(anova(model)$"Pr(>F)"[1], 2)
      vioplot(expr.mat[tx_name[i],]~as.numeric(covar.table[,factor_name]), xlab = "", 
        main = paste(tx_label[i], "\np =", model.p), col = "lightgray",
        cex.names = cex.labels, cex.axis = cex.labels, ylab = "")
      mtext(ylab, side = 2, line = 2.5, cex = cex.labels)
      stripchart(expr.mat[tx_name[i],]~as.numeric(covar.table[,factor_name]), 
        col = pt_col, vertical = TRUE, pch = 16, method = "jitter", add = TRUE)
    }
  }
}
```

### Genotype

```{r klotho_genotype, fig.width = 8, fig.height = 8}
plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
  tx_name = tx.id, tx_label = paste0("Kl Transcript", 1:length(tx.id)), 
  ylab = "Expression (A.U.)", order.by.mean = FALSE)

if(final.params){
  pdf(here("Results", "for_paper", 
    paste0("Klotho_expression_by_genotype_", basename(results.dir), "_months.pdf")), 
    width = 5, height = 6)
    par(bg = NA)
  plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
    tx_name = tx.id, "ordered_geno", 
    tx_label = paste0("Kl Transcript", 1:length(tx.id)), 
    ylab = "Expression (A.U.)", order.by.mean = FALSE)
  dev.off()
}
```


### Sex

```{r klotho_sex, fig.width = 8, fig.height = 4}
par(mfrow =  c(1,2))
plot_tx_with_factor(expr.mat = scaled.expr, covar.table = covar.mat, 
  tx_name = tx.id, factor_name = "sex_ge", 
  tx_label = paste0("Kl Transcript", 1:length(tx.id)), 
  ylab = "Expression (A.U.)")

if(final.params){
  pdf(here("Results", "for_paper", 
    paste0("Klotho_expression_by_sex_", basename(results.dir), "_months.pdf")), 
    width = 5, height = 5)
    par(bg = NA)
  plot_tx_with_factor(expr.mat = scaled.expr, covar.table = covar.mat, 
    tx_name = tx.id, factor_name = "sex_ge", 
    tx_label = paste0("Kl Transcript", 1:length(tx.id)), 
    ylab = "Expression (A.U.)", cex.labels = 1.5)
  dev.off()
}
```

### Age

```{r klotho_age, fig.width = 8, fig.height = 4}
age.varies <- length(unique(covar.mat[,"age_batch"])) > 1
if(age.varies > 0){
  par(mfrow = c(1,2))
  plot_tx_with_factor(expr.mat = scaled.expr, covar.table = covar.mat, 
    tx.id, "age_batch", paste0("Kl Transcript", 1:length(tx.id)), 
    ylab = "Expression (A.U.)", cex.labels = 1.5)
}else{
  plot.text("Age does not vary in this population")
}

if(age.varies > 0 && use.carrier.status){
  pdf(here("Results", "for_paper", 
    paste0("Klotho_expression_by_sex_", basename(results.dir), "_months.pdf")), 
    width = 5, height = 5)
    par(bg = NA)
  age.varies <- which(colnames(covar.mat) == "age_batch")
  plot_tx_with_factor(expr.mat = scaled.expr, covar.table = covar.mat, 
    tx.id, "age_batch", "numeric", 
    paste0("Kl Transcript", 1:length(tx.id)), 
    ylab = "Expression (A.U.)", cex.label = 1.5)
  dev.off()
}
```

## Related genes {.tabset .tabset-fade .tabset-pills}

alpha-klotho, which is primarily expressed in the brain,
activates FGF23/Fgf23. Here we look at the influence of 
Klotho genotype on transcript levels of Fgf23. Klotho 
genotype did not influence expression of Fgf23.

It has also been suggested that Apoe genotype interacts 
with Klotho genotype. Mice have the Apoe4 allele, and it
has been shown that people with the APOE4 allele who are
also VS carriers are protected against AD. We don't have
variation in Apoe genotype in these mice, but we can at 
least look for variation in Apoe4 expression based on 
Klotho genotype. 

```{r downstream, fig.width = 8, fig.height = 8, results = "asis"}
test.genes <- c("Fgf23" = "ENSMUSG00000000182", "Apoe" = "ENSMUSG00000002985")

for(tx in 1:length(test.genes)){
  cat("###", names(test.genes)[tx], "\n")
  
  if(expression.type == "transcript"){
    tx.id <- gene.info[which(test.genes[tx] %in% gene.info[,"ensembl_gene_id"]), "ensembl_transcript_id"]
    tx.present <- intersect(tx.id, rownames(scaled.expr))
  }else{
    tx.present <- intersect(test.genes[tx], rownames(scaled.expr))
  }

  if(length(tx.present) > 0){
    transcript.levels <- scaled.expr[tx.present,]

    plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
      tx_name = tx.present, 
      tx_label = paste(names(test.genes)[tx], "transcript", 1:length(tx.present)), 
      ylab = "Expression (A.U.)")
  }else{
    plot.text(paste(names(test.genes)[tx], "not found"))
  }
  cat("\n\n")
}
```


## Differential Expression

We tested for differential expression with the different factors.
For each factor, we adjusted the expression matrix for the other
factors and test for the final factor.

```{r one_model}
test_full_model <- function(expr.mat, covar.mat){
  
  full.model.file <- file.path(results.dir, 
    paste0("Full_Model_Results_", carrier.text, ".RDS"))
  
  if(!file.exists(full.model.file)){
    #match covariates to adjusted expression matrix
    common.ind <- intersect(colnames(expr.mat), rownames(covar.mat))
    expr.idx <- match(common.ind, colnames(expr.mat))
    covar.idx <- match(common.ind, rownames(covar.mat))

    #adjust for sequencing batch
    dummy.batch <- dummy_covar(covar.mat[covar.idx,"sequencingBatch",drop=FALSE])

    adj.expr.file <- file.path(processed.data.dir, "Batch_Adjusted_Expr.RDS")
    if(!file.exists(adj.expr.file)){
      adj.expr <- adjust(t(expr.mat[,expr.idx]), dummy.batch)
      saveRDS(adj.expr, adj.expr.file)
    }else{
      adj.expr <- readRDS(adj.expr.file)
    }

    #test one to get factor names
    df <- cbind("expr" = adj.expr[,1], covar.mat)
    age.varies <- length(unique(covar.mat$age_batch)) > 1
    if(age.varies){
      diff.test <- lm(expr~(sex_ge+age_batch+scaled_Ide_expression+ordered_geno)^2, data = df)
    }else{
      diff.test <- lm(expr~(sex_ge+scaled_Ide_expression+ordered_geno)^2, data = df)
    }
    factor.names <- rownames(anova(diff.test))
    num.factors <- length(factor.names)-1

    #test all main effects and interactions
    effect.p <- matrix(NA, nrow = ncol(adj.expr), ncol = num.factors)
    colnames(effect.p) <- factor.names[1:num.factors]
    model.r2 <- rep(NA, ncol(adj.expr))
    for(i in 1:ncol(adj.expr)){
      df <- cbind("expr" = adj.expr[,i], covar.mat)
      if(age.varies){
        diff.test <- lm(expr~(sex_ge+age_batch+scaled_Ide_expression+ordered_geno)^2, data = df)
      }else{
        diff.test <- lm(expr~(sex_ge+scaled_Ide_expression+ordered_geno)^2, data = df)
      }
      model.r2[i] <- summary(diff.test)$adj.r.squared
      effect.p[i,] <- anova(diff.test)$"Pr(>F)"[1:num.factors]
      #coef(diff.test)
    }
    rownames(effect.p) <- names(model.r2) <- colnames(adj.expr)
    #par(mar = c(12,4,4,2)); boxplot(-log10(effect.p), las = 2, ylab = "-log10(p)")
    #plot.decomp(t(-log10(effect.p)), label.points = TRUE)
    result <- list("p_values" = effect.p, "R2" = model.r2)
    saveRDS(result, full.model.file)
  }else{
    result <- readRDS(full.model.file)
  }
    return(result)
}
```

We first used a linear model to test for main effects of each
covariate along with interactions between the covariates.

```{r test_full}
full.model.result <- test_full_model(expr.mat = scaled.expr, covar.mat = covar.mat)
effect.p <- full.model.result$p_values
model.r2 <- full.model.result$R2

#take out the genes with the largest sex effect. These are all X and Y genes.
#the transcripts have smaller effects overall
sex.effect.threshold = get.percentile(-log10(effect.p[,"sex_ge"]), 99.95)
big.sex.effect <- which(-log10(effect.p[,"sex_ge"]) > sex.effect.threshold)
big.sex.genes <- gene.info[match(names(big.sex.effect), gene.info[,id_col]),]

#also take out Ide itself
ide.effect <- which(-log10(effect.p[,"scaled_Ide_expression"]) > 10)

effect.p <- effect.p[-c(big.sex.effect, ide.effect),]
```

we removed the genes with the sex effects greater than `r sex.effect.threshold`.
There were `r nrow(big.sex.genes)` with effects this large. They are shown below.
The genes reside mostly on the sex chromosomes.

```{r sex_genes}
colnames(big.sex.genes) <- c("geneID", "geneName","entrezID", "Chr", "start", "end")
datatable(big.sex.genes)
```

The box plot below shows the distributions of the effects
of each factor with the sex-specific genes removed.

```{r p_box}
par(mar = c(12,4,4,2))
boxplot(-log10(effect.p), las = 2, ylab = "-log10(p)")
```

The following are qq plots for each p value distribution.
These are interesting. It looks as if almost every gene's
transcription is affected by Klotho genotype. There are many
that are affected by age. There is a large effect of sex, but
not as big as the age or genotype effect.

There really arent any genes with an interaction effect between
sex and genotype. Same for the interaction between sex and genotype.
This is unexpected.

There are many more genes that have a sex by age interaction.

```{r qq}
effect.fdr  <- apply(effect.p, 2, function(x) p.adjust(x, "fdr"))
model.r2 <- model.r2[-big.sex.effect]

layout(get.layout.mat(ncol(effect.p)))
for(i in 1:ncol(effect.p)){
  qqunif.plot(effect.p[,i], plot.label = colnames(effect.p)[i])
}
```

The following bar plot shows the number of genes with significant
effects due to each factor with an FDR less than `r fdr.thresh`.

Klotho genotype affected expression of the most genes, followed
by age. Sex affected very few, which I think is consistent with
previous results in the brain. 

A handful of genes had a sex by age interaction, and two had
a genotype by age interaction. 

```{r factor_sig}
factor.fdr <- apply(effect.p, 2, function(x) p.adjust(x, "fdr"))
sig.factor <- apply(factor.fdr, 2, function(x) which(x <= fdr.thresh))
#sig.factor <- apply(effect.p, 2, function(x) which(x <= 0.01))
num.sig <- sapply(sig.factor, length)
par(mar = c(12, 4, 4, 2))
barplot_with_num(num.sig, las = 2, ylab = "Count")

if(final.params){
  saveRDS(num.sig, here("Results", "for_paper", paste0("num_de_", basename(results.dir), ".RDS")))
}
```

The following heat map shows enrichments for genes that were
nominally significant for each main effect or interaction. 

```{r enrich, fig.width = 7, fig.height = 7}
enrich <- lapply(sig.factor, function(x) gost(names(x), organism = "mmusculus", 
  sources = c("GO", "KEGG", "CORUM", "HP", "REACTOME")))
plot.enrichment.group(enrich, max.term.size = 3000, transformation = sqrt, max.char = 100)
```

Interaction plots for any genes with significant age by genotype
interactions are printed to the results folder for this run
in a pdf called age_geno_int.pdf.

```{r age_geno_int}
adj.expr <- readRDS(file.path(processed.data.dir, "Batch_Adjusted_Expr.RDS"))

age.geno.col <- which(colnames(factor.fdr) == "age_batch:ordered_geno")

if(length(age.geno.col) > 0){
  sig.idx <- which(factor.fdr[,age.geno.col] <= fdr.thresh)

  if(length(sig.idx) > 0){
    pdf(file.path(results.dir, paste0("age_geno_int_", carrier.text, ".pdf")), 
      width = 7, height = 5)
      for(i in 1:length(sig.idx)){
        gene.id <- rownames(factor.fdr)[sig.idx[i]]
        model <- lm(adj.expr[,gene.id]~covar.mat[,"age_batch"]*covar.mat[,"ordered_geno"])
        #summary(model)
        #anova(model)
        #gene.id <- sample(rownames(factor.fdr), 1)
        gene.name <- gene.info[which(gene.info[,id_col] == gene.id),"external_gene_name"]
        interaction.plot(covar.mat[,"age_batch"], covar.mat[,"ordered_geno"], adj.expr[,gene.id], col = geno.cols, lwd = 3,
          xlab = "Age", ylab = "Expression", main = gene.name, trace.label = "genotype")
      }
    dev.off()
  }
}
```

Interaction plots for genes with significant sex by genotype
interactions are printed to the results folder for this run
in a pdf called sex_geno_int.pdf.


```{r sex_geno_int}
sex.geno.col <- which(colnames(factor.fdr) == "sex_ge:ordered_geno")

if(length(sex.geno.col) > 0){
  sig.idx <- which(factor.fdr[,sex.geno.col] <= fdr.thresh)

  if(length(sig.idx) > 0){
    pdf(file.path(results.dir, paste0("sex_geno_int_", carrier.text, ".pdf")), 
      width = 7, height = 5)
    for(i in 1:length(sig.idx)){
      gene.id <- rownames(factor.fdr)[sig.idx[i]]
      model <- lm(adj.expr[,gene.id]~covar.mat[,"sex_ge"]*covar.mat[,"ordered_geno"])
      #summary(model)
      #anova(model)
      #gene.id <- sample(rownames(factor.fdr), 1)
      gene.name <- gene.info[which(gene.info[,id_col] == gene.id),"external_gene_name"]
      interaction.plot(covar.mat[,"sex_ge"], covar.mat[,"ordered_geno"], adj.expr[,gene.id], col = geno.cols, lwd = 3,
        xlab = "Sex", ylab = "Expression", main = gene.name, trace.label = "genotype")
    }
    dev.off()
  }
}
```

```{r write_de_table}
#all parameter iterations are written out to compare later
#for the paper, so these are written regardless of whether
#final.params is TRUE or FALSE
de.files <- get.files(here("Results", "for_paper"), want = c("num_de", "RDS"), full.names = TRUE)
factor.labels <- c("sex_ge" = "sex", "ordered_geno" = "Klotho genotype", "age_batch" = "age")

if(length(de.files) > 1){
  num.de <- lapply(de.files, readRDS)
  names(num.de) <- gsub(".RDS", "", gsub("num_de_", "", basename(de.files)))
  all.factors <- Reduce("union", lapply(num.de, names))

  count.table <- matrix(NA, ncol = length(all.factors), nrow = length(num.de))
  colnames(count.table) <- all.factors
  rownames(count.table) <- names(num.de)
  for(i in 1:length(num.de)){
    count.table[i,names(num.de[[i]])] <- num.de[[i]]
  }
  #for now, make group a column, so we can turn it into a LaTeX table more easily
  count.table <- cbind("group" = names(num.de), count.table)

  for(i in 1:length(factor.labels)){
    colnames(count.table) <- gsub(names(factor.labels)[i], factor.labels[i], colnames(count.table))
  }

  write.table(count.table, here("Results", "for_paper", "num_de_table.txt"), 
    row.names = FALSE, na = "--", quote = FALSE, sep = "\t")

  #cd to ~/Documents/git_repositories/LaTeX-Table-Generator
  #run python3 table_generator.py
  #move the result from Outputs to the for_paper directory
  #open the file and paste the table into the manuscript document
  #paste the result into LaTeXit to test if needed.
}
```

## DEG by genotype

The heatmap below shows the mean expression of 
differentially expressed genes for each genotype.
This is with an fdr value of `r fdr.thresh`. 

```{r sig_expr, fig.width = 10, fig.height = 4}
sig.geno.idx <- which(effect.fdr[,"ordered_geno"] <= fdr.thresh)

sig.expr <- scaled.expr[names(sig.geno.idx),]

#divide into groups based on carrier status
alleles <- levels(geno_factor)
allele.idx <- lapply(alleles, function(x) which(geno_factor == x))
names(allele.idx) <- alleles

diff.expr <- lapply(allele.idx, function(x) sig.expr[,x])
mean.sig.expr <- sapply(diff.expr, rowMeans)
colnames(mean.sig.expr) <- alleles

expr.clust <- pam(mean.sig.expr, k = 2)
col.order <- order(expr.clust$clustering)
annot.col <- data.frame(as.factor(expr.clust$clustering))
colnames(annot.col) <- "cluster"
pheatmap(t(mean.sig.expr[col.order,alleles]), show_colnames = FALSE, cluster_cols = FALSE, 
  cluster_rows = FALSE, annotation_col = annot.col)

gene.names <- gene.info[match(rownames(annot.col), 
  gene.info[,id_col]), "external_gene_name"]
write.table(cbind(gene.names, mean.sig.expr, annot.col)[order(annot.col[,1]),], 
  file.path(results.dir, paste0("DEG_clusters_", carrier.text, ".txt")), 
  sep = "\t", quote = FALSE)
```

```{r deg_fig}
cluster.id <- expr.clust$clustering
if(final.params){
  png(here("Results", "for_paper", "deg_clusters.png"), width = 7, height = 3,  units = "in", res = 300)
  scaled.mat <- t(apply(mean.sig.expr[col.order,alleles], 1, scale))
  dimnames(scaled.mat) <- dimnames(mean.sig.expr[,alleles])

  layout.mat <- matrix(c(1,2), nrow = 1)
  layout(layout.mat, widths = c(1, 0.2))
  par(mar = c(2,4,4,1), xpd = NA)
  imageWithText(t(scaled.mat), show.text = FALSE, use.pheatmap.colors = TRUE,
    col.names = NULL, row.text.shift = 0.07, row.text.adj = 0.5)
  plot.dim <- par("usr")
  plot.height <- plot.dim[4] - plot.dim[3]
  plot.width <- plot.dim[2] - plot.dim[1]
  c1.mid <- mean(which(cluster.id[col.order] == 1))
  c2.mid <- mean(which(cluster.id[col.order] == 2))
  label.y <- (plot.dim[4]+(plot.height*0.09))
  text(x = c1.mid, y = label.y, labels = "Neuron and Synapse")
  text(x = c2.mid, y = label.y, labels = "Mitochondria and Ribosome")

  #add colored labels for the genotypes
  y.vals <- 1:length(ordered.geno)
  y.shift <- plot.height*0.06
  label.xmin <- plot.dim[1] - (plot.width*0.09)
  label.xmax <- plot.dim[1] + (plot.width*0.03)
  for(i in 1:length(y.vals)){
    draw.rectangle(label.xmin, label.xmax, (y.vals[i] - y.shift), (y.vals[i] + y.shift),
      border = geno.cols[match(rev(ordered.geno)[i], names(geno.cols))], 
      lwd = 3)
  }

  #add scale bar
  par(mar = c(2,4,4,1))
  imageWithTextColorbar(mean.sig.expr, use.pheatmap.colors = TRUE, cex = 1, bar.lwd = 3)
  dev.off()
}
```

We clustered these genes into two groups and looked at enrichment.
The enrichments of the groups are shown below.

```{r enrich_groups}
group.genes <- lapply(1:2, function(x) rownames(annot.col)[which(annot.col[,1] == x)])
group.enrich = lapply(group.genes, function(x) gost(x, organism = "mmusculus",
  sources = c("GO", "KEGG", "REACOME", "CORUM", "HP", "WP")))
names(group.enrich) <- c(1,2)
plot.enrichment.group(group.enrich, max.term.size = 3000, n.terms = 15)
```

```{r enrichment_tables}
if(final.params){
  pdf(here("Results", "for_paper", "Enrichment.pdf"), width = 8, height = 7)
  for(i in 1:length(group.enrich)){
    plot.enrichment(group.enrich[[i]], plot.label = paste("Cluster", i), 
      max.term.size = 3000, num.terms = 15)
  }
  dev.off()
}
```

The following correlation matrix heat map shows that the 
VS homo- and heterozygote effects are correlated with each
other, as are the FC homo- and heterozygote effects. The VS
and FC effects are negatively correlated with each other, 
meaning that when the FC genotype has increased expression 
of a gene, the VS genotype tends to have decreased expression
of that gene.

The FC genotypes are more correlated with each other than 
the VS genotypes suggesting that the heterozygote and homozygote
of the VS alleles have different effects more often than the
homo- and heterozygote of the FC alleles. 

The WT mice are also more correlated with the FC than with the
VS animals.

```{r geno_cor, fig.width = 4, fig.height = 4}
pheatmap(cor(mean.sig.expr), display_numbers = TRUE)
```

The following table shows functional enrichments for the group
of genes that are differentially expressed across Klotho genotypes.

```{r enrich_genotype, fig.width = 7, fig.height = 7}
sig.enrich <- gost(rownames(mean.sig.expr), organism = "mmusculus", 
  sources = c("GO", "KEGG", "REACTOME", "CORUM", "HP", "HPA"))
plot.enrichment(sig.enrich, plot.label = "DEG by Klotho genotype", num.terms = 30,
  max.term.size = 3000)
```

The following plot is a wordcloud version of the above data.

```{r enrich_word, fig.width = 12, fig.height = 6}
#pdf("~/Desktop/overall_enrich.pdf", width = 12, height = 7)
par(mfrow = c(1,2), mar = c(0,0,0,0))
plot.enrichment.wordcloud(sig.enrich, plot.label = "DEG by Klotho genotype", num.terms = 20,
  max.term.size = 3000, just.wordcloud = FALSE)
#dev.off()
```

The following plot shows that compared with WT mice,
the FC and VS alleles have opposing effects on many 
genes.

```{r enrich_by_group, fig.width = 5, fig.height = 5}
vs.idx <- grep("VS", colnames(mean.sig.expr))
vs.mean <- rowMeans(mean.sig.expr[,vs.idx,drop=FALSE])

fc.idx <- grep("FC", colnames(mean.sig.expr))
fc.mean <- rowMeans(mean.sig.expr[,fc.idx,drop=FALSE])

plot(vs.mean, fc.mean, xlab = "VS mean expression", 
  ylab = "FC mean expression")
abline(h = 0, v = 0)
```

The following plot shows the enrichments for the genes in 
each quadrant above.

```{r fc_v_vs, fig.width = 7, fig.height = 7}

quads <- pair.matrix(c("up", "down"), TRUE, TRUE)
enrich.idx <- vector(mode = "list", length = nrow(quads))
for(i in 1:nrow(quads)){
  if(quads[i,1] == "up"){
    x.idx <- which(vs.mean > 0)
  }else{
    x.idx <- which(vs.mean < 0)
  }

  if(quads[i,2] == "up"){
    y.idx <- which(fc.mean > 0)
  }else{
    y.idx <- which(fc.mean < 0)
  }
  enrich.idx[[i]] <- intersect(x.idx, y.idx)
}

quad.enrich <- lapply(enrich.idx, function(x) gost(names(vs.mean)[x], 
  organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME", "CORUM", "HP")))

#pdf("~/Desktop/enrichment.pdf", width = 10, height = 10)
layout.matrix <- matrix(c(4,1,3,2), nrow = 2, byrow = TRUE)
layout(layout.matrix)
par(mar = c(4,0,4,0))
for(i in 1:length(quad.enrich)){
  if(i == 3){max.cex = 2}else{max.cex = 2.5}
  plot.enrichment.wordcloud(quad.enrich[[i]], max.term.size = 3000,
  plot.label = "", just.wordcloud = TRUE, max.cex = max.cex, num.terms = 30)
  mtext(paste0("VS ", quads[i,1], "; FC ", quads[i,2]), side = 3, font = 2)
  plot.dim <- par("usr")
  draw.rectangle(plot.dim[1],plot.dim[2],plot.dim[3],plot.dim[4])
}
#dev.off()
```

## AD Gene expression {.tabset .tabset-fade .tabset-pills}

We are interested in how Klotho genotype affects expression 
of genes that have previously been associated with Alzheimer's 
disease. There are many ways of making a list of "AD genes."
Here we include three:


1. The list of AD-associated genes from Agora: 
  https://agora.adknowledgeportal.org/genes/nominated-targets
  This is their list of nominated targets. We can separate the genes 
  by evidence, e.g. gene expression, protein levels, genetic evidence, 
  etc. Here we look at all AD genes. Greg said that this list might
  draw the ire of reviewers, so we will skip it.

2. A list of genes from a meta-analysis done by Greg Cary et al. 
  (PMID: 38650747) for TREAT-AD. The idea of this study was to look 
  across the human cohorts and across tissues (excluding cerebellum, 
  because it isn't very affected by AD), and assess the overall differential 
  abundance of transcripts and proteins. In the table above we have included 
  the treatment effect (“_TE”) for every gene and protein measured - essentially 
  a logFC value. There is also a significance attached to each difference 
  ("_fdr_CorPVal"). This is frequently used as a global list, and I will try 
  that here, looking only at the genes with differential transcript abundance.
  This list is too long (12k genes), so it doesn't seem all that useful.

3. The list of genes from Bellenguez et al. This list is pretty widely 
  accepted as a good list. We can use just table 1, which was gene prioritizations
  for known loci, or we can include table 2, which includes novel loci.


Each of these lists is looked at one at a time with the same code. 
We only need one AD list.

```{r ad_genes}
#list.which <- "Agora"
#list.which <- "meta"
#list.which <- "Bellenguez"
list.which <- "KEGG"

if(list.which == "Agora"){
  #ad.gene.list <- read.delim(here("Data", "Human", "AD_genes.txt"), header = FALSE) #from book
  ad.gene.list <- read.csv(here("Data", "Human", "agora-gene-list.csv"), comment.char = "#")

  #we can filter by a number of features:
  #filter to those with RNA evidence
  #has.rna <- grep("RNA", ad.gene.list[,"Input.Data"])
  #ad.gene.list <- ad.gene.list[has.rna,]

  #pick genes with more than one nomination
  #multiple.noms <- which(ad.gene.list[,"Nominations"] > 1)
  #ad.gene.list <- ad.gene.list[multiple.noms,]
  ad.genes <- ad.gene.list[,1]
}

if(list.which == "meta"){
  meta.file <- file.path(human.data.dir, "TREAT-AD_meta_syn22758536.csv")
  if(!file.exists(meta.file)){
    synLogin()
    logged.in <- TRUE
    query <- synTableQuery("SELECT * FROM syn22758536")
    ad.gene.list <- read.table(query$filepath, sep = ",", header = TRUE)
  }
  ad.gene.list <- read.csv(meta.file)
  fdr.level <- 0.01
  rna.fdr <- ad.gene.list$RNA_fdr_CorPVal
  #hist(rna.fdr)
  #sig.idx <- which(ad.gene.list$RNA_Sig == "YES")
  sig.idx <- which(rna.fdr <= fdr.level)
  #length(sig.idx)
  ad.genes <- ad.gene.list$GName[sig.idx]
}

if(list.which == "Bellenguez"){
  tbl1 <- read.delim(file.path(human.data.dir, "Bellenguez_table1.txt"))
  tbl2 <- read.delim(file.path(human.data.dir, "Bellenguez_table2.txt"))
  ad.genes <- unique(c(tbl1[,"Gene"], tbl2[,"Gene"], "APOE"))
  #ad.genes <- unique(c(tbl1[,"Gene"], "APOE"))
}
  
if(list.which == "KEGG"){
  kegg.idx <- which(names(hum.path.gene.ensembl) == "Alzheimer disease")
  ad.id <- hum.path.gene.ensembl[[kegg.idx]]
  ad.id <- ad.id[which(!is.na(ad.id))]
  ad.genes <- orthos[match(ad.id, orthos[,"Human.Ensembl"]),"Human.Gene.Name"]
}


common.ad <- intersect(ad.genes, orthos[,"Human.Gene.Name"])
ad.orthos <- orthos[match(common.ad, orthos[,"Human.Gene.Name"]),"Mouse.Ortholog.Name"]
ad.ensembl <- intersect(gene.info[match(intersect(ad.orthos, gene.info[,"external_gene_name"]), 
  gene.info[,"external_gene_name"]), id_col], rownames(effect.fdr))
ad.sig <- intersect(rownames(mean.sig.expr), ad.ensembl)
```

## Differential expression of `r list.which` AD genes

```{r ad_ind_expr, fig.height = 8, fig.width = 7}
plot.ad <- ad.ensembl
#plot.ad <- ad.sig

ad.names <- gene.info[match(plot.ad, gene.info[,id_col]),"external_gene_name"]
#write out the names we are using for comparison later
gene.mat <- matrix(ad.names, ncol = 1)
colnames(gene.mat) <- paste(list.which, "genes", sep = "_")
write_table_with_header(gene.mat, file.path(results.dir, "AD_genes.txt"), 
  header = paste("Genes selected as AD genes from the", list.which, "list"))

ad.idx <- match(plot.ad, rownames(scaled.expr))
ordered.ind <- unlist(allele.idx)
ordered.expr <- scaled.expr[ad.idx,ordered.ind]
rownames(ordered.expr) <- ad.names
#row.order <- order(pam(ordered.expr, k = 2)$cluster)
row.order <- order(plot.decomp(ordered.expr, plot.results = FALSE)$u[,1])

#png("~/Desktop/ad_genes.png", width = 7, height = 12, units = "in", res = 300)
#quartz(width = 7, height = 8)
edge.nudge = 0
imageWithText(ordered.expr[row.order,], use.pheatmap.colors = TRUE, show.text = FALSE,
  col.names = NULL, row.text.shift = 0.01)
plot.dim <- par("usr")
start.idx <- 0.5
for(i in 1:length(alleles)){
  end.idx <- start.idx + length(allele.idx[alleles][[i]]) - edge.nudge
  draw.rectangle(start.idx, end.idx, 0+0.5, plot.dim[4]-10, border = "darkgray", lwd = 3)
  draw.rectangle(start.idx, end.idx, plot.dim[4]-10, plot.dim[4]+10, fill = geno.cols[i])
  mid.point <- mean(c(start.idx, end.idx))
  text(x = mid.point, y = plot.dim[4], labels = alleles[i])
  start.idx <- end.idx + edge.nudge
}
#dev.off()
```

```{r ad_mean_expr}
mean.ad <- sapply(allele.idx, function(x) rowMeans(scaled.expr[ad.idx,x]))
sig.star <- rep("", length(ad.names))
sig.star[which(ad.ensembl %in% ad.sig)] <- "*"
rownames(mean.ad) <- paste0(ad.names, sig.star)
#row.order <- order(pam(mean.ad, 2)$cluster)
row.order <- order(plot.decomp(mean.ad, plot.results = FALSE)$u[,1])

png("~/Desktop/ad_means.png", width = 12, height = 4, units = "in", res = 300)
par(bg = NA)
imageWithText(t(mean.ad[row.order,]), use.pheatmap.colors = TRUE, show.text = FALSE,
  row.text.shift = 0.02, row.text.adj = 1, col.text.shift = 0.13)
plot.dim <- par("usr")
for(i in 1:length(ordered.geno)){
  draw.rectangle(-4.5, 0, 6-i-0.3, 6-i+0.3, border = geno.cols[ordered.geno[i]], lwd = 3, fill = NA)
}
dev.off()

mean.sig <- sapply(allele.idx, function(x) rowMeans(scaled.expr[ad.sig,x]))
rownames(mean.sig) <- gene.info[match(rownames(mean.sig), gene.info[,id_col]), "external_gene_name"]
row.order <- order(plot.decomp(mean.sig, plot.results = FALSE)$u[,1])

png("~/Desktop/ad_means_sig.png", height = 20, width = 3, units = "in", res = 300)
par(bg = NA)
imageWithText(mean.sig[row.order,], use.pheatmap.colors = TRUE, show.text = FALSE,
  col.text.shift = 0.02, col.text.adj = 1, row.text.shift = 0.2, col.text.rotation = 0)
plot.dim <- par("usr")
for(i in 1:length(ordered.geno)){
  draw.rectangle(-35.5, 0, 6-i-0.4, 6-i+0.4, border = geno.cols[ordered.geno[i]], lwd = 3, fill = NA)
}
dev.off()
 
#enrichments of these groups don't tell us much, because they
#are just enriched for AD genes, which is why we selected them.
#sig.decomp <- plot.decomp(mean.sig)
#abline(v = 0.01)
#c1 <- which(sig.decomp$u[,1] < 0.01)
#c2 <- which(sig.decomp$u[,1] > 0.01)
#cenrich <- lapply(list("c1" = ad.sig[c1], "c2" = ad.sig[c2]), function(x) gost(x, organism = 'mmusculus'))
#plot.enrichment.group(cenrich, transformation = "sqrt")

#plot.enrichment(cenrich[[1]], num.terms = 30)
#plot.enrichment(cenrich[[2]], num.terms = 30)

#quartz(width = 1.5, height = 3)
#imageWithTextColorbar(mean.ad, use.pheatmap.colors = TRUE, cex = 0.7, bar.lwd = 3)
```



```{r fig_ad_marked}
if(final.params){
  
cluster.id <- expr.clust$clustering
  png(here("Results", "for_paper", "deg_clusters.png"), width = 7, height = 3.5,  units = "in", res = 300)
  par(bg = NA)
  scaled.mat <- t(apply(mean.sig.expr[col.order,alleles], 1, scale))
  dimnames(scaled.mat) <- dimnames(mean.sig.expr[,alleles])

  layout.mat <- matrix(c(1,2), nrow = 1)
  layout(layout.mat, widths = c(1, 0.2))
  par(mar = c(2,4,4,1), xpd = NA)
  imageWithText(t(scaled.mat), show.text = FALSE, split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends",
    col.names = NULL, row.text.shift = 0.07, row.text.adj = 0.5)
  plot.dim <- par("usr")
  plot.height <- plot.dim[4] - plot.dim[3]
  plot.width <- plot.dim[2] - plot.dim[1]
  c1.idx <- which(cluster.id[col.order] == 1)
  c2.idx <- which(cluster.id[col.order] == 2)
  c1.mid <- mean(c1.idx)
  c2.mid <- mean(c2.idx)
  label.y <- (plot.dim[4]+(plot.height*0.09))
  text(x = c1.mid, y = label.y, labels = "Mitochondria and Ribosome")
  text(x = c2.mid, y = label.y, labels = "Neuron and Synapse")

  #add colored labels for the genotypes
  y.vals <- 1:length(ordered.geno)
  y.shift <- plot.height*0.06
  label.xmin <- plot.dim[1] - (plot.width*0.09)
  label.xmax <- plot.dim[1] + (plot.width*0.03)
  for(i in 1:length(y.vals)){
    draw.rectangle(label.xmin, label.xmax, (y.vals[i] - y.shift), (y.vals[i] + y.shift),
      border = geno.cols[match(rev(ordered.geno)[i], names(geno.cols))], 
      lwd = 3)
  }

  #add markes for AD genes
  #ad.id <- gene.info[match(ad.orthos, gene.info[,"external_gene_name"]), "ensembl_gene_id"]
  #to.mark <- intersect(ad.id[which(!is.na(ad.id))], rownames(scaled.mat))
  #ad.idx <- match(to.mark, rownames(scaled.mat))
  #text(x = ad.idx, y = 0.35, labels = "|", col = "#756bb1")
  #text(x = -65, y = 0.35, labels = "AD gene", adj = 1)
  #c1.ad.perc <- round(length(intersect(ad.idx, c1.idx))/length(c1.idx)*100)
  #c2.ad.perc <- round(length(intersect(ad.idx, c2.idx))/length(c2.idx)*100)
  #text(x = c1.mid, y = 0, labels = paste0(c1.ad.perc, "% AD"))
  #text(x = c2.mid, y = 0, labels = paste0(c2.ad.perc, "% AD"))

  #add scale bar
  par(mar = c(2,4,4,1))
  imageWithTextColorbar(mean.sig.expr, split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), cex = 1, bar.lwd = 3, 
    grad.dir = "ends")
  dev.off()
}

```

```{r deg_supp_table}

sig.info <- gene.info[match(rownames(mean.sig.expr), gene.info[,id_col]),]
expr.table <- mean.sig.expr
colnames(expr.table)  <- paste0(colnames(expr.table), "_mean_expression")
is.agora <- rep("no", nrow(sig.info))
is.agora[which(sig.info[,"external_gene_name"] %in% ad.orthos)] <- "yes"
sig.gene.pval <- effect.p[match(sig.info[,1], rownames(effect.p)),"ordered_geno"]
sig.gene.fdr <- effect.fdr[match(sig.info[,1], rownames(effect.fdr)),"ordered_geno"]
supp.table <- cbind(sig.info, expr.table, "p" = sig.gene.pval,
  "fdr" = sig.gene.fdr, "Agora_target" = is.agora, 
  "Cluster_ID" = cluster.id[rownames(mean.sig.expr)])

if(final.params){
  write.table(supp.table, here("Results", "for_paper", "Supp_Table_DEG.csv"),
    sep = ",", quote = FALSE, row.names = FALSE)
}

#p.order <- order(sig.gene.pval, decreasing = FALSE)
#head(supp.table[p.order,])
#expr.col <- grep("expression", colnames(supp.table))
#top.decomp <- plot.decomp(supp.table[p.order[1:25],expr.col])
#pc.order <- order(top.decomp$u[,1])
#top.mat <- supp.table[p.order[1:25],expr.col]
#imageWithText(as.matrix(top.mat), col.scale = c("blue", "brown"), split.at.vals = TRUE, grad.dir = "ends", show.text = FALSE)
```

## Individual AD genes {.tabset .tabset-fade .tabset-pills}

There were multiple individual genes of interest in 
this list:

APOE was upregulated in the VS animals
reltaive to WT and FC animals. APOE mRNA has been shown 
to be more abundant in AD brains (PMID: 7751846, 27104063), 
so this possibly contradicts the protective effect of the VS 
allele.

Celf1 is also low in the VS animals relative to the FC animals. 
It has been previously shown that CELF1 expression is low in AD 
brains (mentioned in PMID: 38768546), so this also possibly
contradicts the protective effect of the VS allele.

Trem2 is downregulated in the FC animals relative to the others.
This could be protective since Trem2 is more highly expressed
in AD brains and may be associated with increased macrophage
recruitment (PMID: 33516818).

So we see a mixed bag with expression of individual genes.
Thus far, the VS mice do not look as if their brains have
less AD-like expression.

```{r ad_interest, results = "asis", fig.width = 7, fig.height = 7}
ad.interest <- c("App", "Apoe", "Celf1", "Trem2", "Sorl1", "Bin1", "Adam10", "Cr1l")
#pdf("~/Desktop/AD-genes.pdf")
for(i in 1:length(ad.interest)){
  cat("###", ad.interest[i], "{.tabset .tabset-fade .tabset-pills}\n")
  gene.id <- gene.info[which(gene.info[,"external_gene_name" ]%in% ad.interest[i]), id_col]
  for(j in 1:length(gene.id)){
    cat("####", gene.id[j], "\n")
    test <- plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
      tx_name = gene.id[j], tx_label = paste(ad.interest[i], gene.id), 
      ylab = "Expression (A.U.)",
      order.by.mean = FALSE, plot.results = TRUE)
    cat("\n\n")
  }

  if(expression.type == "transcript"){
    cat("#### Overall\n")
    par(mfrow = c(1,1))
    tx.expr <- lapply(allele.idx, function(x) t(scaled.expr[gene.id,x]))
    plot.grouped.boxes(tx.expr, type = "matrix", print.vals = NA, 
    cex.names = 0.5, main = ad.interest[i], ylab = "Transcript Expression (A.U.)", 
    group.cols = geno.cols)
    plot.dim <- par("usr")
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = 0)
    cat("\n\n")
  }
  cat("\n\n")
}
#dev.off()
```

```{r test_genes, eval = FALSE}
test.interest <- c("Snrnp200", "Depdc5")
#test.interest <- sample(gene.info[,"external_gene_name"], 1)
pdf("~/Desktop/test_genes.pdf")
for(i in 1:length(test.interest)){
  gene.id <- gene.info[which(gene.info[,"external_gene_name" ]%in% test.interest[i]), id_col]
  test <- plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
    tx_name = gene.id, tx_label = paste(test.interest[i], gene.id), ylab = "Expression (A.U.)",
    order.by.mean = FALSE, plot.results = TRUE)

  if(expression.type == "transcript"){
    par(mfrow = c(1,1))
    tx.expr <- lapply(allele.idx, function(x) t(scaled.expr[gene.id,x]))
    plot.grouped.boxes(tx.expr, type = "matrix", print.vals = NA, las = 2, 
    main = test.interest[i], ylab = "Transcript Expression (A.U.)")
    plot.dim <- par("usr")
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = 0)
  }
}
dev.off()
```

```{r ad_interest_fig}
if(final.params){
  pdf(here("Results", "for_paper", "AD-related_expression.pdf"), width = 7, height = 7)
  for(i in 1:length(ad.interest)){
    gene.id <- gene.info[which(gene.info[,"external_gene_name" ]%in% ad.interest[i]), id_col]
    test <- plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
      tx_name = gene.id, tx_label = paste(ad.interest[i], gene.id), ylab = "Expression (A.U.)",
      order.by.mean = FALSE, plot.results = TRUE, cex.labels = 1.5)
  
    if(expression.type == "transcript"){
      par(mfrow = c(1,1))
      tx.expr <- lapply(allele.idx, function(x) t(scaled.expr[gene.id,x]))
      plot.grouped.boxes(tx.expr, type = "matrix", print.vals = NA, las = 2, 
      main = ad.interest[i], ylab = "Transcript Expression (A.U.)")
      plot.dim <- par("usr")
      segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = 0)
    }

  }
dev.off()
}

```

## Biodomains {.tabset .tabset-fade .tabset-pills}
We also looked at differential expression based on the biodomains
described in PMID: 38650747. The lists are stored at syn25760039. 
The synIDs for the individual files are listed in 
Synapse_IDs_biodomain_gene_lists.csv.

There is also a table stored at syn25428992, that annotates
the GO terms. Each row in this table is a GO term. The information 
in each row tells you which biodomain and which subdomain the
GO term is included in. This is how Greg makes those boxplots
in which each dot is a GO term, and the position is the normalized
enrichment score from GSEA. The dots are grouped by domain. I am not
going to worry about the subdomains right now, but it will be handy
to have the lists of genes in each GO term.

For now, I will make a list of genes in each domain, translate those
to mouse orthologs and test for enrichment among differentially 
expressed genes.

```{r get_biodomains}
biodomain.dir <- here("Data", "Biodomains")
if(!file.exists(biodomain.dir)){dir.create(biodomain.dir)}

#make a list of the genes in each biodomain
file.dest <- file.path(biodomain.dir, "annotated_biodomains_Oct23.rds")
if(!file.exists(file.dest)){
  synGet(syn25428992, downloadLocation = biodomain.dir)
}

annotated_bd <- readRDS(file.path(biodomain.dir, "annotated_biodomains_Oct23.rds"))
u_bd <- unique(annotated_bd$Biodomain)

bd_genes <- vector(mode = "list", length = length(u_bd))
names(bd_genes) <- u_bd
for(bd in 1:length(u_bd)){
  bd.idx <- which(annotated_bd$Biodomain == u_bd[bd])  
  bd_genes[[bd]] <- Reduce("union", annotated_bd$ensembl_id[bd.idx])
}
saveRDS(bd_genes, file.path(general.processed.data.dir, "Human_Biodomains_for_GSEA.RDS"))


#also gather subdomains in a nested list
sbd_genes <- vector(mode = "list", length = length(u_bd))
names(sbd_genes) <- u_bd
for(bd in 1:length(u_bd)){
  bd.idx <- which(annotated_bd$Biodomain == u_bd[bd])  
  sbd.names <- unique(annotated_bd$Subdomain[bd.idx])
  sbd.names <- sbd.names[which(!is.na(sbd.names))]
  if(length(sbd.names) > 0){
    sbd_list <- vector(mode = "list", length = length(sbd.names))
    names(sbd_list) <- sbd.names
    for(sbd in 1:length(sbd.names)){
      sbd.idx <- which(annotated_bd$Subdomain == sbd.names[sbd])  
      sbd_list[[sbd]] <- Reduce("union", annotated_bd$ensembl_id[sbd.idx])
    }
    sbd_genes[[bd]] <- sbd_list
  }
}
saveRDS(sbd_genes, file.path(general.processed.data.dir, "Human_Subdomains_for_GSEA.RDS"))

```

The biodomains are in terms of human genes. We need to translate 
these to mouse orthologs.

```{r ortho}
mouse.bd.genes <- vector(mode = "list", length = length(bd_genes))
names(mouse.bd.genes) <- names(bd_genes)

for(i in 1:length(bd_genes)){
  bd.with.ortho <- intersect(bd_genes[[i]], orthos[,"Human.Ensembl"])
  bd.idx <- match(bd.with.ortho, orthos[,"Human.Ensembl"])
  bd.gene.id <- orthos[bd.idx,c("Mouse.Ortholog.Ensembl", "Mouse.Ortholog.Name")]
  colnames(bd.gene.id) <- c("ensembl_gene_id", "external_gene_name")
  if(expression.type == "gene"){
    mouse.bd.genes[[i]] <- bd.gene.id
  }
  if(expression.type == "transcript"){
    bd.gene.idx <- which(gene.info[,"ensembl_gene_id"] %in% bd.gene.id[,"ensembl_gene_id"])
    bd.trans.id <- gene.info[bd.gene.idx,c("ensembl_transcript_id", "ensembl_gene_id", "external_gene_name")]
    mouse.bd.genes[[i]] <- bd.trans.id
  }
}

bd.for.gsea <- lapply(mouse.bd.genes, function(x) x[,id_col])
saveRDS(bd.for.gsea, file.path(general.processed.data.dir, 
  paste0("Mouse_Biodomains_", expression.type, "_for_GSEA.RDS")))

#do the same for subdomains
mouse.sbd.genes <- vector(mode = "list", length = length(sbd_genes))
names(mouse.sbd.genes) <- names(sbd_genes)

for(i in 1:length(sbd_genes)){
  if(length(sbd_genes[[i]]) > 0){
    sbd.list <- vector(mode = "list", length = length(sbd_genes[[i]]))
    names(sbd.list) <- names(sbd_genes[[i]])
    for(s in 1:length(sbd.list)){
      sbd.with.ortho <- intersect(sbd_genes[[i]][[s]], orthos[,"Human.Ensembl"])
      sbd.idx <- match(sbd.with.ortho, orthos[,"Human.Ensembl"])
      sbd.genes <- orthos[sbd.idx,c("Mouse.Ortholog.Ensembl", "Mouse.Ortholog.Name")]
      colnames(sbd.genes) <- c("ensembl_gene_id", "external_gene_name")
      if(expression.type == "gene"){
        sbd.list[[s]] <- sbd.genes
      }
      if(expression.type == "transcript"){
        sbd.gene.idx <- which(gene.info[,"ensembl_gene_id"] %in% sbd.genes[,"ensembl_gene_id"])
        sbd.trans.id <- gene.info[sbd.gene.idx,c("ensembl_transcript_id", "ensembl_gene_id", "external_gene_name")]
        sbd.list[[s]] <- sbd.trans.id
      }
    }
    mouse.sbd.genes[[i]] <- sbd.list
  }
}

sbd.for.gsea <- lapply(mouse.sbd.genes, function(x) lapply(x, function(y) y[,1]))
saveRDS(sbd.for.gsea, file.path(general.processed.data.dir, 
  paste0("Mouse_Subdomains_", expression.type, "_for_GSEA.RDS")))

```

```{r go_terms}
#also save gene/transcript lists for all GO terms in each biodomain
#This is how Greg Cary makes his enrichment boxplots. He
#gets a normalized enrichment score for each GO term and plots
#all those together for each biodomain
#take any GO term with at least nim.term.size genes
mouse_go_list <- human_go_list <- vector(mode = "list", length = length(bd_genes))
names(mouse_go_list) <- names(human_go_list) <- names(bd_genes)
for(bd in 1:length(bd_genes)){
  bd.idx <- which(annotated_bd$Biodomain == names(bd_genes)[bd])
  bd_go <- annotated_bd$GOterm_Name[bd.idx]
  go_genes <- annotated_bd$ensembl_id[bd.idx]
  names(go_genes) <- bd_go
  num.genes <- sapply(go_genes, length)
  human_go_genes <- go_genes[which(num.genes >= min.term.size)] 
  dups <- which(duplicated(names(human_go_genes)))
  dup.idx <- lapply(dups, function(x) which(names(human_go_genes) == names(human_go_genes)[x]))
  keep.idx <- unique(sapply(dup.idx, function(x) x[1]))
  delete.idx <- setdiff(unique(unlist(dup.idx)), keep.idx)
  no.dups <- setdiff(1:length(human_go_genes), delete.idx)
  human_go_list[[bd]] <- human_go_genes[no.dups]
    
  common_go_genes <- lapply(human_go_genes[no.dups], function(x) intersect(x, orthos[,"Human.Ensembl"]))
  mouse_go_genes <- lapply(common_go_genes, function(x) orthos[match(x, orthos[,"Human.Ensembl"]),"Mouse.Ortholog.Ensembl"])
  num.mouse <- sapply(mouse_go_genes, length)
  mouse_gene_list <- mouse_go_genes[which(num.mouse >= min.term.size)]
  if(expression.type == "transcript"){
    mouse.gene.idx <- lapply(mouse_gene_list, function(x) match(x, gene.info[,"ensembl_gene_id"]))
    transcript.list <- lapply(mouse.gene.idx, function(x) gene.info[x[which(!is.na(x))],id_col])
    mouse_go_list[[bd]] <- transcript.list
  }else{
    mouse_go_list[[bd]] <- mouse_gene_list
  }
}

saveRDS(mouse_go_list, file.path(general.processed.data.dir, 
  paste0("Mouse_Biodomains_sub_GO_for_GSEA_", expression.type, ".RDS")))
saveRDS(human_go_list, file.path(general.processed.data.dir, 
  paste0("Human_Biodomains_sub_GO_for_GSEA_", expression.type, ".RDS")))
```

## Biodomain Expression {.tabset .tabset-fade .tabset-pills}

The following heat maps show the mean expression of genes
across each biodomain. Each has been clustered by medoid
clustering into the best number of clusters (always 2).


If we are looking at gene expression, the two variants seem 
to have opposing expression relative to the WT. If we are 
looking at transcripts, the genotypes don't look different
at all, but the means are slightly different. There are many
transcripts, so the means can be significantly different even
if they don't look that different.

```{r biodomain_expression}
mean.bd.val.file <- file.path(processed.data.dir, 
  paste0("mean_biodomain_expression_", carrier.text, ".RDS"))

if(!file.exists(mean.bd.val.file)){
  mean.bd.vals <- vector(mode = "list", length = length(mouse.bd.genes))
  names(mean.bd.vals) <- names(mouse.bd.genes)

  for(bd in 1:length(mouse.bd.genes)){
    #print(names(mouse.bd.genes)[bd])
    bd.vals <- lapply(1:nrow(mouse.bd.genes[[bd]]), 
      function(x) plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
        tx_name = mouse.bd.genes[[bd]][x,id_col], 
        tx_label = mouse.bd.genes[[bd]][x,"external_gene_name"], 
        plot.results = FALSE)[[1]])

    has.vals <- which(sapply(bd.vals, length) > 0)
    bd.mean <- t(sapply(bd.vals[has.vals], function(x) sapply(x[[1]], mean)))
    rownames(bd.mean) <- sapply(bd.vals[has.vals], names)
    mean.bd.vals[[bd]] <- bd.mean
  }
  saveRDS(mean.bd.vals, mean.bd.val.file)
}else{
  mean.bd.vals <- readRDS(mean.bd.val.file)
}

#boxplot(mean.bd.vals$"Mitochondrial Metabolism")
#barplot(colMeans(mean.bd.vals$"Mitochondrial Metabolism"))
```

```{r cluster_bd, results = "asis", fig.width = 8, fig.height = 4}
#In previous runs I tried 2 to 10 clusters. All ended up with 2,
#so I am just setting k = 2 here to save time, but leaving the 
#code for testing for future work. 

clustered.gene.file <- file.path(results.dir, paste0("Clustered_Coef_", carrier.text, ".RDS"))
clustered.enrich.file <- file.path(results.dir, paste0("Clustered_Enrich_", carrier.text, ".RDS"))

if(!file.exists(clustered.gene.file)){
  #k.seq = 2:4
  clustered.genes <- gene.enrich <- vector(mode = "list", length = length(mean.bd.vals))
  names(clustered.genes) <- names(gene.enrich) <- names(mean.bd.vals)

  for(i in 1:length(mean.bd.vals)){
    #print(names(mean.bd.vals)[bd])
    #test.k <- test.pam.k(mean.bd.vals[[i]], plot.results = FALSE, kseq = k.seq)
    #mean.cl.width <- sapply(test.k$cl.width, mean)
    #barplot(mean.cl.width)
    #select the number of clusters with the best separation among clusters.
    #k = as.numeric(names(mean.cl.width)[which.max(mean.cl.width)])
    k = 2
    final.clust <- pam(mean.bd.vals[[i]], k = k)
    clustered.genes[[i]] <- final.clust$clustering
    cluster.enrich <- lapply(1:k, function(x) gost(names(clustered.genes[[i]])[which(clustered.genes[[i]] == x)], 
      organism = "mmusculus", source = c("GO", "KEGG", "REACTOME", "HP", "CORUM")))
    names(cluster.enrich) <- paste0("cluster", 1:k)
    gene.enrich[[i]] <- cluster.enrich
    #plot.enrichment.group(cluster.enrich, max.term.size = 3000, n.terms = 30, cluster_cols = FALSE, plot.label = names(mean.bd.vals)[i])
  }
  saveRDS(clustered.genes, clustered.gene.file)
  saveRDS(gene.enrich, clustered.enrich.file)
}else{
  clustered.genes <- readRDS(clustered.gene.file)
  gene.enrich <- readRDS(clustered.enrich.file)
}

bd.means <- matrix(nrow = length(mean.bd.vals), ncol = length(alleles))
rownames(bd.means) <- names(mean.bd.vals)
colnames(bd.means) <- alleles

#pdf("~/Desktop/test.pdf", width = 8, height = 4)
for(i in 1:length(mean.bd.vals)){
  cat("###", names(mean.bd.vals)[i], "\n")
  #pheatmap(t(mean.bd.vals[[i]][names(clustered.genes[[i]])[order(clustered.genes[[i]])],]), 
  #  cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, main = names(mean.bd.vals)[i])
  par(mfrow = c(1,2))
  par(mar = c(4,4,4,0))
  clustered.mat <- t(mean.bd.vals[[i]][names(clustered.genes[[i]])[order(clustered.genes[[i]])],])
  
  if(group.representation == "means"){
    cluster.means <- rowMeans(clustered.mat)
  }
  if(group.representation == "eigengene"){
    cluster.decomp <- plot.decomp(t(clustered.mat), plot.results = FALSE, cols = geno.cols[rownames(clustered.mat)], label.points = TRUE)
    cluster.means <- cluster.decomp$v[,1]
    names(cluster.means) <- rownames(clustered.mat)
    #barplot(cluster.means, col = geno.cols[names(cluster.means)])
  }

  bd.means[i,] <- cluster.means
  imageWithText(clustered.mat, 
    show.text = FALSE, use.pheatmap.colors = TRUE, col.names = NULL)
  par(mar = c(4,4,4,2))
  #p values seem to depend only on how many genes are in the group
  diff.test <- aov.by.matrix(t(clustered.mat))
  diff.p <- summary(diff.test)[[1]]$"Pr(>F)"[1]
  vioplot(t(clustered.mat), main = "", horizontal = TRUE, las = 2, col = geno.cols,
    names = rep("", nrow(clustered.mat)), axes = FALSE)
  axis(1)
  plot.dim <- par("usr")
  segments(x0 = 0, y0 = plot.dim[3], y1 = plot.dim[4])
  mtext("Expression (A.U.)", side = 1, line = 2.5)
  mtext(names(mean.bd.vals)[i], side = 3, outer = TRUE, font = 2, line = -2.5)
  plot.height <- plot.dim[4] - plot.dim[3]
  plot.width <- plot.dim[2] - plot.dim[1]
  nudge.y <- 0.03
  nudge.x <- 0.02
  label.y <- segment_region((plot.dim[3]+(plot.height*nudge.y)), 
    (plot.dim[4]-(plot.height*nudge.y)), 
    nrow(clustered.mat))
  label.x <- plot.dim[1] + ((plot.dim[2]-plot.dim[1])*nudge.x)
  text(x = label.x, y = label.y, labels = alleles)
  cat("\n\n")  
}
#dev.off()
```


## Biodomain Expression Summary

The following plot shows a summary of the mean expression
of the biodomains in each genotype.

```{r bd_summary, fig.width = 7, fig.height = 7}
bd.mean.decomp <- plot.decomp(t(bd.means), plot.results = FALSE)
row.order <- order(bd.mean.decomp$v[,1])

layout.mat <- matrix(c(1,2), nrow = 1)
layout(layout.mat, widths = c(1, 0.5))
par(mar = c(4,18, 2,1))
imageWithText(signif(bd.means[row.order,], 2), split.at.vals = TRUE, 
  col.scale = c("blue", "brown"), grad.dir = "ends", row.text.shift = 0.25,
  col.text.shift = 0.03)
par(mar = c(4,1,2,2))
barplot(bd.mean.decomp$v[row.order,1], horiz = TRUE, xlab = "PC1")
plot.dim <- par("usr")
segments(x0 = 0, y0 = plot.dim[3], y1 = plot.dim[4])
```


## Subdomains {.tabset .tabset-fade .tabset-pills}

We did the same analysis above for the subdomains.

The following heat maps show the mean expression of genes
across each subdomain. Each has been clustered by medoid
clustering.

```{r subdomain_expression}
sbd.mean.file <- file.path(results.dir, paste0("Subdomain_Mean_Expr_", carrier.text, ".RDS"))
if(!file.exists(sbd.mean.file)){
  mean.sbd.vals <- vector(mode = "list", length = length(mouse.sbd.genes))
  names(mean.sbd.vals) <- names(mouse.sbd.genes)

  for(bd in 1:length(mouse.sbd.genes)){
    #cat(names(mouse.sbd.genes)[bd], "\n")
    if(length(mouse.sbd.genes[[bd]]) > 0){
      sub.means <- vector(mode = "list", length = length(mouse.sbd.genes[[bd]]))
      names(sub.means) <- names(mouse.sbd.genes[[bd]])
      for(s in 1:length(mouse.sbd.genes[[bd]])){
        #cat("\t", names(mouse.sbd.genes[[bd]])[s], "\n")
        sbd <- mouse.sbd.genes[[bd]][[s]]
        sbd.vals <- lapply(1:nrow(sbd), 
          function(x) plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
            tx_name = sbd[x,id_col], tx_label = sbd[x,"external_gene_name"], 
            ylab = "Expression (A.U.)", plot.results = FALSE)[[1]])

        has.vals <- which(sapply(sbd.vals, length) > 0)
        sbd.mean <- t(sapply(sbd.vals[has.vals], function(x) sapply(x[[1]], mean)))
        rownames(sbd.mean) <- sapply(sbd.vals[has.vals], names)
        sub.means[[s]] <- sbd.mean
      }
    }
    mean.sbd.vals[[bd]] <- sub.means
  }
  saveRDS(mean.sbd.vals, sbd.mean.file)
}else{
  mean.sbd.vals <- readRDS(sbd.mean.file)
}
```

```{r cluster_sbd}
clustered.sd.file <- file.path(results.dir, paste0("Clustered_Coef_SBD_", carrier.text, ".RDS"))
#clustered.sd.enrich.file <- file.path(results.dir, "Clustered_Enrich_SBD.RDS")

if(!file.exists(clustered.sd.file)){
  clustered.sd.genes <- vector(mode = "list", length = length(mean.sbd.vals))
  names(clustered.sd.genes) <- names(mean.sbd.vals)

  for(bd in 1:length(mean.sbd.vals)){

      if(length(mean.sbd.vals[[bd]]) > 0){
          clustered.sd <- vector(mode = "list", length = length(mean.sbd.vals[[bd]]))
          names(clustered.sd) <- names(mean.sbd.vals[[bd]])
          for(s in 1:length(mean.sbd.vals[[bd]])){
            k = 2
            if(length(mean.sbd.vals[[bd]][[s]]) > 0){
              final.clust <- pam(mean.sbd.vals[[bd]][[s]], k = k)
              clustered.sd[[s]] <- final.clust$clustering
              #cluster.enrich <- lapply(1:k, function(x) gost(names(clustered.genes[[i]])[which(clustered.genes[[i]] == x)], 
              #  organism = "mmusculus", source = c("GO", "KEGG", "REACTOME", "HP", "CORUM")))
              #names(cluster.enrich) <- paste0("cluster", 1:k)
              #gene.enrich[[i]] <- cluster.enrich
              #plot.enrichment.group(cluster.enrich, max.term.size = 3000, n.terms = 30, cluster_cols = FALSE, plot.label = names(mean.bd.vals)[i])
            }
          }
      clustered.sd.genes[[bd]] <- clustered.sd
      }
    }
    saveRDS(clustered.sd.genes, clustered.sd.file)
    #saveRDS(gene.enrich, clustered.enrich.file)
}else{
  clustered.sd.genes <- readRDS(clustered.sd.file)
  #gene.enrich <- readRDS(clustered.enrich.file)
}
```

```{r plot_clustered_sbd, results = "asis", fig.width = 8, fig.height = 4}
num.sbd <- sum(sapply(mean.sbd.vals, length))
sbd.means <- matrix(nrow = num.sbd, ncol = length(alleles))
sbd.names <- vector(mode = "list", length = length(mean.sbd.vals))
for(i in 1:length(mean.sbd.vals)){
  sbd.names[[i]] <- paste(names(mean.sbd.vals)[i], names(mean.sbd.vals[[i]]), sep = " : ")
}
rownames(sbd.means) <- unlist(sbd.names)
colnames(sbd.means) <- alleles

#pdf("~/Desktop/test_sd.pdf", width = 8, height = 4)
idx <- 1
for(bd in 1:length(mean.sbd.vals)){
  cat("###", names(mean.sbd.vals[bd]), "{.tabset .tabset-fade .tabset-pills}\n")
  if(length(mean.sbd.vals[[bd]]) > 0){
    for(s in 1:length(mean.sbd.vals[[bd]])){
      cat("####", names(mean.sbd.vals[[bd]][s]), "\n")
      #pheatmap(t(mean.bd.vals[[i]][names(clustered.genes[[i]])[order(clustered.genes[[i]])],]), cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, main = names(mean.bd.vals)[i])
      par(mfrow = c(1,2))
      par(mar = c(4,4,4,0))
      clustered.mat <- t(mean.sbd.vals[[bd]][[s]][names(clustered.sd.genes[[bd]][[s]])[order(clustered.sd.genes[[bd]][[s]])],])
      if(group.representation == "means"){
        cluster.means <- rowMeans(clustered.mat)
      }
      if(group.representation == "eigengene"){
        cluster.means <- plot.decomp(t(clustered.mat), plot.results = FALSE)$v[,1]
        names(cluster.means) <- rownames(clustered.mat)
      }

      mean.order <- order(cluster.means)
      sbd.means[idx,] <- cluster.means
      imageWithText(clustered.mat[mean.order,], 
        show.text = FALSE, use.pheatmap.colors = TRUE, col.names = NULL)
      par(mar = c(4,4,4,2))
      #p values seem to depend only on how many genes are in the group
      diff.test <- aov.by.matrix(t(clustered.mat))
      diff.p <- summary(diff.test)[[1]]$"Pr(>F)"[1]
      vioplot(t(clustered.mat), main = "", horizontal = TRUE, 
        las = 2, col = geno.cols, names = rep("", length(alleles)))
      plot.dim <- par("usr")
      segments(x0 = 0, y0 = 0, y1 = plot.dim[4])
      mtext(rownames(sbd.means)[idx], side = 3, outer = TRUE, font = 2, line = -2.5)
      cat("\n\n")  
      idx <- idx + 1
      cat("\n\n")
    }
  }
  cat("\n\n")
}
#dev.off()
```


## Subdomain Expression Summary

The following plot shows a summary of the mean expression
of the subdomains in each genotype. Because there are so
many subdomains, we subset to only those with a |PC1| value
greater than 0.5.

```{r sbd_summary, fig.width = 15, fig.height = 8}
sbd.decomp <- plot.decomp(sbd.means, plot.results = FALSE)
big.idx <- which(abs(sbd.decomp$u[,1]) > 0.1)
row.order <- order(sbd.decomp$u[big.idx,1])

#png("~/Desktop/sbd_overview.png", width = 15, height = 8, units = "in", res = 300)
layout.mat <- matrix(c(1,2), nrow = 1)
layout(layout.mat, widths = c(1, 0.5))
par(mar = c(4,35, 2,1))
imageWithText(signif(sbd.means[big.idx[row.order],], 2), split.at.vals = TRUE, 
  col.scale = c("blue", "brown"), grad.dir = "ends", row.text.shift = 0.15,
  col.text.shift = 0.05)
par(mar = c(4,1,2,2))
barplot(sbd.decomp$u[big.idx[row.order],1], horiz = TRUE, xlab = "PC1")
plot.dim  <- par("usr")
segments(x0 = c(-0.1, 0, 0.1), y0 = 0, y1 = plot.dim[4], lty = c(2,1,2))
#dev.off()
```


## KEGG

KEGG pathways are AD-agnostic and are organized into different
functional groups that could be informative. We also looked at
gene expression based on KEGG pathways.

For each mouse KEGG pathway, is there differential expression across genotypes?
The results are printed to pdfs in the results folder. There are too many
KEGG pathways to display here.


```{r diff_kegg, fig.width = 7, fig.height = 12}
mean.kegg.val.file <- file.path(results.dir, 
  paste0("mean_kegg_expression_", carrier.text, ".RDS"))

if(!file.exists(mean.kegg.val.file)){
  mean.kegg.vals <- vector(mode = "list", length = length(mouse.path.gene.ensembl))
  names(mean.kegg.vals) <- names(mouse.path.gene.ensembl)

  for(k in 1:length(mouse.path.gene.ensembl)){
    #cat(names(mouse.path.gene.ensembl)[k], "\n")
    k.vals <- lapply(1:length(mouse.path.gene.ensembl[[k]]), 
      function(x) plot_tx_with_genotype(expr.mat = scaled.expr, covar.table = covar.mat, 
        tx_name = mouse.path.gene.ensembl[[k]][x], 
        tx_label = NA, ylab = "Expression (A.U.)", plot.results = FALSE)[[1]])

    has.vals <- which(sapply(k.vals, length) > 0)
    k.mean <- t(sapply(k.vals[has.vals], function(x) sapply(x[[1]], mean)))
    #pheatmap(k.mean)
    mean.kegg.vals[[k]] <- k.mean
  }
  saveRDS(mean.kegg.vals, mean.kegg.val.file)
}else{
  mean.kegg.vals <- readRDS(mean.kegg.val.file)
}
```

Below is the qq plot for p values just for an ANOVA
looking for mean differences across the genotypes.
We picked an arbitraty threshold (marked below) for 
looking at examples.

```{r test_diff, fig.width = 5, fig.height = 5}
logp.thresh = 10
test.diff <- lapply(mean.kegg.vals, aov.by.matrix)
test.p <- sapply(test.diff, function(x) summary(x)[[1]]$"Pr(>F)"[1])
qqunif.plot(test.p, plot.label = "KEGG pathway differences by genotype")
abline(h = logp.thresh)
```

The heat map below shows the average expression in the top 
KEGG pathways for each genotype. The pathways are the same 
as we've seen before: metabolism and neurodegeneration.

```{r plot_example_kegg, fig.height = 7, fig.width = 7}
if(group.representation == "means"){
  mean.mean <- t(sapply(mean.kegg.vals, colMeans))
}
if(group.representation == "eigengene"){
  mean.mean <- t(sapply(mean.kegg.vals, function(x) plot.decomp(x, plot.results = FALSE)$v[,1]))
  #mean.mean <- sapply(mean.kegg.vals, function(x) plot.decomp(t(x), plot.results = FALSE)$u[,1])
}

sig.path <- which(-log10(test.p) > 10)
term.name = names(sig.path)[2]
term.idx <- which(names(mean.kegg.vals) == term.name)
#boxplot(mean.kegg.vals[[term.idx]], main = term.name, ylab = "Scaled Expression")
#pheatmap(mean.kegg.vals[[term.idx]], main = term.name, show_rownames = FALSE, cluster_cols = FALSE)
#mean.kegg.vals[[term.idx]]


top.decomp <- plot.decomp(mean.mean[sig.path,], plot.results = FALSE)
row.order <- order(top.decomp$u[,1])
layout(matrix(c(1,2), nrow = 1), widths = c(1, 0.2))
par(mar = c(4,16,4,2))
imageWithText(mean.mean[sig.path[rev(row.order)],], show.text = FALSE, split.at.vals = TRUE,
  col.scale = c("blue", "brown"), grad.dir = "ends", col.text.rotation = 0,
  col.text.adj = 0.5, col.text.shift = 0.1, row.text.shift = 0.3, 
  main = "Top KEGG pathways")
par(mar = c(20,2,4,2))
imageWithTextColorbar(mean.mean[sig.path[row.order],], split.at.vals = TRUE,
  col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1)

```

```{r logout}
if(need.to.download){
  synLogout()
}
```



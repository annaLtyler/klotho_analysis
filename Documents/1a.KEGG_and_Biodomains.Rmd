---
title: "KEGG and Biodomains"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
---

The purpose of this workflow is to explore the effect of
two human Klotho variants on gene expression in mice. It 
follows directly from 1.Klotho_Initial_Data_Visualization.Rmd
and depends on output from that workflow.

```{r param}
rm(list = ls())

library(here)

args <- commandArgs(trailingOnly=T)
subgroup <- args[2]

if(is.na(subgroup)){
  #subgroup <- "all ages"
  subgroup <- list("age_batch" = 12)
  #subgroup <- list("age_batch" = 4)
  #subgroup <- list("age_batch" = 4, "sex_climb" = "Female") #example with more than one filter
}

if(subgroup == "all ages"){
  results.dir <- here("Results", "all")
}else{
  subgroup.results <- paste(sapply(1:length(subgroup), 
    function(x) paste(names(subgroup)[x], subgroup[[x]], sep = "_")), 
    collapse = "_")
  results.dir <- here("Results", subgroup.results)
}

general.data.dir <- here("Data", "general")


use.carrier.status = TRUE #if true, fits models with the ordered factor FC > WT > VS
                          #if false, fits modesl with the ordered factor FC/FC > FC/WT > WT/WT > WT/VS > VS/VS

select_by = "R2" #decide whether to select pathway intersections by R2 threshold or PC loading
#select_by = "PC"

path.fdr.thresh = 0.001 #FDR threshold for selecting by R-squared
                        #if select_by == "PC", this is ignored and 
                        #the top 1% from each end is taken
                        #should be 0.01 if use.carrier.status == FALSE
                        #and 0.001 if use.carrier.status = TRUE

#group.representation <- "eigengene" #decide whether a group of genes will be represented by 
                                   #their mean expression or the first PC of their expression
                                   #matrix (eigengene)
                                   #the eigengene version gives very strange results that I'm
                                   #not sure what to make of, so I'm abandoning that for now.
group.representation <- "means"
```

The subgroup analyzed in this workflow is:
`r paste(names(subgroup), subgroup, sep = " = ")`

```{r load_code}
all.fun <- list.files(here("Code"), full.names = TRUE)
for(i in 1:length(all.fun)){source(all.fun[i])}

processed.data.dir <- file.path(results.dir, "processed_data")
general.processed.data.dir <- here("Results", "Processed_Data")
mouse.data.dir <- here("Data", "Mouse")

geno.cols <- get_geno_cols(here("Data", "general", "geno_cols.csv"))
ordered.geno <- c("FC/FC", "WT/FC", "WT/WT", "WT/VS", "VS/VS")
if(use.carrier.status){
    geno.cols <- geno.cols[c("FC/FC", "WT/WT", "VS/VS")]
    names(geno.cols) <- c("FC", "WT", "VS")
    ordered.geno <- c("FC", "WT", "VS")
}
```

```{r libraries, message = FALSE, warning = FALSE, error = FALSE}
needed.libraries <- c("pheatmap", "vioplot", "RColorBrewer",
  "gprofiler2", "cluster", "pathview", "stringr", "igraph", "wordcloud",
  "wordcloud2", "baffle", "parallel", "foreach", "doParallel", "VennDiagram")
load_libraries(needed.libraries)
```

```{r read_data}
mouse.info <- read.csv(file.path(mouse.data.dir, "metadata_validated.csv"))
orthos <- read.delim(file.path(general.data.dir, "human.mouse.orthologs.txt"))
mouse.genes <- read.delim(here("Data", "general", "mouse_gene_info.txt"))
covar.table <- read.table(file.path(processed.data.dir, "mouse_info.csv"), sep = ",", header = TRUE, row.names = 1)

#add factors for ordered genotypes and ordered carrier status
covar.table$ordered_geno <- ordered(covar.table[,"climb_geno"], levels = ordered.geno)
carrier.factor <- rep("WT", nrow(covar.table))
carrier.factor[grep("VS", covar.table[,"climb_geno"])] <- "VS"
carrier.factor[grep("FC", covar.table[,"climb_geno"])] <- "FC"
carrier.factor <- ordered(carrier.factor, levels = c("FC", "WT", "VS"))
covar.table$carrier_status <- carrier.factor


if(use.carrier.status){
    test.factor <- covar.table[,"carrier_status"]
}else{
    test.factor <- covar.table[,"ordered_geno"]
}

raw.expr <- read.table(here("Data", "Mouse", "rsem.merged.gene_counts.tsv"), header = TRUE)
norm.expr <- readRDS(file.path(processed.data.dir, "Normalized_Expression.RDS"))
scaled.expr <- readRDS(file.path(processed.data.dir, "Scaled_Expression.RDS"))

#gene lists for KEGG, GO, Biodomains, and the intersections
bd.list <- readRDS(file.path(general.processed.data.dir, "Mouse_Biodomains_for_GSEA.RDS"))
sub.bd.list <- readRDS(file.path(general.processed.data.dir, "Mouse_Subdomains_for_GSEA.RDS"))
bd.go.list <- readRDS(file.path(general.processed.data.dir, "Mouse_Biodomains_sub_GO_for_GSEA.RDS"))
kegg.list <- readRDS(file.path(general.processed.data.dir, "Mouse_KEGG_for_GSEA.RDS"))
kegg.bd.list <- readRDS(file.path(general.processed.data.dir, "Mouse_KEGG_Intersections_for_GSEA.RDS"))

#Jaccard indices for intersections
kegg.bd.jaccard <- readRDS(file.path(general.processed.data.dir, "Mouse_KEGG_Intersection_Jaccard.RDS"))

#read in the list of AD genes that were selected in 1.Klotho_Initial_Data_Visualization.Rmd
#we can mark them in plots
ad.genes <- read.delim(file.path(results.dir, "AD_genes.txt"), comment.char = "#")
```

We adjusted the expression by non-age covariates.

```{r adjust}
dummy.covar <- dummy_covar(covar.table[,c("sequencingBatch", "sex_ge")])
adj_expr <- adjust(t(scaled.expr), dummy.covar)
```

We made a set of matrices for which rows were KEGG-Biodomain 
intersections and columns were individual mice. The entry in 
each cell is the mean expression value of those genes for that 
mouse. (Initially, we made one matrix for each KEGG pathway. In
each, the rows specify the biodomains.)

```{r intersect_val_fun}
#This function returns mean gene expression values for a vector of genes IDs
#given the expression matrix. The expression matrix should have genes in columns
#and individuals in rows
gene_mean_mat <- function(geneID, expr.mat, group.representation = "means", debugging = FALSE){
    
    common.genes <- intersect(geneID, colnames(expr.mat))
    gene.mat <- expr.mat[,common.genes,drop=FALSE]

    if(length(common.genes) == 1){
        group.representation <- "means"
    }
    if(length(common.genes) > 0){
        if(group.representation == "means"){
            #expression is already scaled across individuals
            #get the mean expression for each individual for 
            #this module
            expr.means <- rowMeans(gene.mat)
        }
        if(group.representation == "eigengene"){
            group.decomp <- plot.decomp(gene.mat, plot.results = FALSE)
            expr.means <- group.decomp$u[,1]
        }

        if(debugging){
            mouse.cols <- sapply(rownames(gene.mat), function(x) geno.cols[covar.table[x,"climb_geno"]])        
            mouse.order <- order(expr.means)
            gene.order <- order(colMeans(gene.mat)) #order the genes by mean expression for better visualization
            model <- lm(expr.means~covar.table[rownames(gene.mat),"carrier_status"])
            model.p <- signif(anova(model)$"Pr(>F)"[1], 2)
            r2 <- signif(summary(model)$adj.r.squared, 2)

            png(paste0("~/Desktop/", gsub(" ", "_", group.representation), ".png"), width = 10, height = 7, units = "in", res = 300)
            layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
            par(mar = c(0,4,2,2))
            barplot(expr.means[mouse.order], names = NA, 
                main = paste0(group.representation, "\nR2 = ", r2, "; p = ", model.p), 
                col = mouse.cols[mouse.order])
            par(mar = c(2,4,0,2))
            #imageWithText(t(gene.mat[mouse.order,gene.order]), split.at.vals = TRUE, col.scale = c("blue", "brown"), show.text = FALSE, row.names = NULL)
            #show the module expression for each individual in the same order as the bars
            boxplot(t(gene.mat[mouse.order,]), col = mouse.cols[mouse.order], las = 2)
            dev.off()
        }
    }else{
        expr.means <- NULL
    }
    return(expr.means)
}

#This function returns individual means for a non-nested
#list of genes, like in bd.list
non_nested_mean_vals <- function(non_nested_gene_list, expr.mat, group.representation = "means"){
    mean.mat <- matrix(NA, nrow = length(non_nested_gene_list), ncol = nrow(expr.mat))
    rownames(mean.mat) <- names(non_nested_gene_list)
    colnames(mean.mat) <- rownames(expr.mat)
    for(i in 1:length(non_nested_gene_list)){
        gene.means <- gene_mean_mat(geneID = non_nested_gene_list[[i]], expr.mat, group.representation)

        #debugging
        #gene.means.eig <- gene_mean_mat(geneID = non_nested_gene_list[[i]], expr.mat, "eigengene", debugging = TRUE)
        #gene.means.mean <- gene_mean_mat(geneID = non_nested_gene_list[[i]], expr.mat, "means", debugging = TRUE)
        #plot.with.model(gene.means.eig, gene.means.mean)

        if(length(gene.means) > 0){
            mean.mat[i,] <- gene.means
        }
    }
    return(mean.mat)
}

#This function creates matrices of mean gene values for individual
#mice for a nested gene list, like kegg.bd.list
#organization lets you toggle between having the rows of each
#matrix be the outer level or the inner level
nested_mean_vals <- function(nested_gene_list, expr.mat, organization = c("outer", "inner"),
    group.representation = group.representation){

    organization <- organization[1]

    #the outer level makes up the rows of each matrix (i.e. biodomains)
    if(organization == "outer"){
        u_inner <- unique(unlist(lapply(nested_gene_list, names)))
        mean.gene.list <- vector(mode = "list", length = length(u_inner))
        names(mean.gene.list) <- u_inner
        #get the gene list for each inner
        for(i in 1:length(u_inner)){
            i.gene.idx <- lapply(nested_gene_list, function(x) which(names(x) == u_inner[i]))
            i.gene.list <- lapply(1:length(i.gene.idx), 
                function(x) if(length(i.gene.idx[[x]]) > 0){nested_gene_list[[x]][[i.gene.idx[[x]]]]})
            names(i.gene.list) <- names(i.gene.idx)
            i.gene.vals <- non_nested_mean_vals(non_nested_gene_list = i.gene.list, expr.mat, 
                group.representation = group.representation)
            #pheatmap(i.gene.vals)
            mean.gene.list[[i]] <- i.gene.vals
        }
    }
    
    if(organization == "inner"){
        u_outer <- names(nested_gene_list)
        mean.gene.list <- vector(mode = "list", length = length(u_outer))
        for(o in 1:length(u_outer)){
            if(length(nested_gene_list[[o]]) > 0){
                o.gene.vals <- non_nested_mean_vals(non_nested_gene_list = nested_gene_list[[o]], 
                    expr.mat, group.representation = group.representation)
                mean.gene.list[[o]] <- o.gene.vals
            }
        }
    }

    return(mean.gene.list)
}


test_effect <- function(values, test.factor, return.text = FALSE,
    plot.results = FALSE, stat.x = 0.1, stat.y = 0.9, stat.y.spread = 0.15, 
    cex.lab = 1, plot.label = "", ylab = "Expression", autoflip.stat.y = FALSE){
    
    model <- lm(values~test.factor)
    #summary(model)

    r2 <- summary(model)$adj.r.squared
    p <- threshold_p(anova(model)$"Pr(>F)"[1], sig.dig = 2, return.text = return.text)
    linear.effect.size <- coefficients(summary(model))["test.factor.L","Estimate"]
    linear.effect.p <- coefficients(summary(model))["test.factor.L","Pr(>|t|)"]
    
        if(plot.results){
            if(return.text){
                text.p <- p
            }else{
                text.p <- threshold_p(p, return.text = TRUE)
            }
            box.cols <- sapply(levels(test.factor), function(x) geno.cols[which(names(geno.cols) == x)])
            vioplot(values~test.factor, col = box.cols, xlab = "", main = plot.label, 
                ylab = "", cex.names = cex.lab)
            mtext(ylab, side = 2, cex = cex.lab, line = 2)
            stripchart(values~test.factor, vertical = TRUE, pch = 16, method = "jitter",
                add = TRUE, col = "#dd1c77")
            plot.dim <- par("usr")
            segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = 0)
            text.x <- fractional_pos(plot.dim[1], plot.dim[2], stat.x)
            if(autoflip.stat.y){
                if(linear.effect.size < 0){
                    stat.y <- 1.1-stat.y #automatically flip if the effect size is negative. not sure if this is a good idea
                }
            }
            text.y <- segment_region(stat.y, stat.y - stat.y.spread, 3, "ends")
            r2.y <- fractional_pos(plot.dim[3], plot.dim[4], text.y[1])
            p.y <- fractional_pos(plot.dim[3], plot.dim[4], text.y[2])
            effect.y <- fractional_pos(plot.dim[3], plot.dim[4], text.y[3])
            text(text.x, r2.y, bquote(italic(R)^2==.(signif(r2, 2))), adj = 0)
            text(text.x, p.y, labels = text.p, adj = 0)
            text(text.x, effect.y, labels = bquote(beta==.(signif(linear.effect.size, 2))), adj = 0)
        }

    result <- list("r2" = r2, "model.p" = p, 
        "linear.effect.size" = linear.effect.size, "linear.effect.p" = linear.effect.p)
    invisible(result)
}

plot_mean_bd_k <- function(mean.bd.k.mat, covar.mat, plot.label = "",
    row.names = rownames(mean.bd.k.mat), label.margin = 12, 
    order.by = c("PC", "top.rank", "means", "genotype", "none"),
    path.stats = c("R2", "effect.size"), 
    plot.results = TRUE, global.min = NULL, global.max = NULL, 
    stat.x = 0.1, stat.y = 0.9, stat.y.spread = 0.15, plot.enrich = FALSE){

    order.by <- order.by[1]
    sub.decomp <- NULL
    pc.r2 <- NULL
    min.val <- global.min
    max.val <- global.max
    path.stats <- path.stats[1]

    if(is.null(min.val)){
        min.val <- min(mean.bd.k.mat, na.rm = TRUE)
    }
    if(is.null(max.val)){
        max.val <- max(mean.bd.k.mat, na.rm = TRUE)
    }
    
    neg.vals <- length(which(mean.bd.k.mat < 0))
    pos.vals <- length(which(mean.bd.k.mat > 0))
    
    if(neg.vals > 0 && pos.vals > 0){
      col.scale = c("blue", "brown")
      grad.dir = "ends"
      split.at.vals = TRUE
    }
    if(neg.vals > 0 && pos.vals == 0){
      col.scale = "blue"
      grad.dir = "low"
      split.at.vals = TRUE
    }
    if(neg.vals == 0 && pos.vals > 0){
      col.scale = "brown"
      grad.dir = "high"
      split.at.vals = TRUE
    }

    has.vals <- which(!is.na(rowMeans(mean.bd.k.mat)))
    if(length(has.vals) > 0){
        sub.mat <- mean.bd.k.mat[has.vals,,drop=FALSE]

        if(!is.null(row.names)){
            row.names <- row.names(sub.mat)
        }

        #align color and genotype information with sub.mat
        #sort individual names into genotypes
        geno.names <- lapply(names(geno.cols), function(x) rownames(covar.mat)[which(test.factor == x)])
        cols <- lapply(1:length(geno.names), function(x) rep(geno.cols[x], length(geno.names[[x]])))
        col.table <- cbind(unlist(geno.names), names(unlist(cols)), unlist(cols))
        #make sure colors and covariates are in the right order
        ordered.table <- col.table[match(colnames(sub.mat), col.table[,1]),]
        ordered.covar <- covar.mat[match(colnames(sub.mat), rownames(covar.mat)),]
        if(use.carrier.status){
           ordered.factor <- ordered.covar[,"carrier_status"]
        }else{
            ordered.factor <- ordered.covar[,"ordered_geno"]
        }
                
        if(length(has.vals) > 1){
            #calcuate overall effect of genotype
            sub.decomp <- plot.decomp(t(sub.mat), cols = ordered.table[,3], plot.result = FALSE)
            model.result <- test_effect(sub.decomp$u[,1], test.factor)
            pc.r2 <- model.result$r2
            pc.p <- threshold_p(model.result$model.p, return.text = TRUE)
            pc.effect <- model.result$linear.effect.size
        }else{
            order.by = "top.rank"
        }
        
        #calculate r2, linear effect size, and p for each row of the matrix
        test <- apply(sub.mat, 1, function(x) if(!all(is.na(x))){test_effect(x, test.factor)}else{NA})    
        ind.r2 <- sapply(test, function(x) x$r2)
        ind.p <- sapply(test, function(x) x$model.p)
        ind.effect <- sapply(test, function(x) x$linear.effect.size)
        
        #define bar values, individual order, path order, plot labels, 
        #and statistics based on the order.by argument
        if(order.by == "top.rank"){
            ind.order <- order(sub.mat[which.max(ind.r2),])
            path.order <- order(ind.r2)
            max.idx <- which.max(ind.r2)
            bar.vals <- sub.mat[max.idx,]
            plot.r2 <- ind.r2[rownames(sub.mat)[max.idx]]
            plot.p <- threshold_p(ind.p[rownames(sub.mat)[max.idx]], return.text = TRUE, sig.dig = 2)
            bar.label <- rownames(sub.mat)[max.idx]
        }
        if(order.by == "PC"){
            ind.order <- order(sub.decomp$u[,1])
            path.order <- order(sub.decomp$v[,1])
            bar.vals <- sub.decomp$u[,1]
            plot.r2 <- pc.r2
            plot.p <- pc.p
            bar.label = "Eigengene"
        }
        if(order.by == "means"){
            ind.order <- order(colMeans(sub.mat, na.rm = TRUE))
            path.order <- order(rowMeans(sub.mat, na.rm = TRUE))
            bar.vals <- colMeans(sub.mat, na.rm = TRUE)
            top.model <- test_effect(bar.vals, test.factor)
            plot.r2 <- top.model$r2
            plot.p <- threshold_p(top.model$model.p)
            bar.label = "Expression Means"
        }
        if(order.by == "genotype"){
            #order first by genotype, and then by eigengene
            sep.geno.order <- lapply(ordered.geno, function(x) which(covar.mat[,"climb_geno"] == x))
            ind.order <- unlist(lapply(sep.geno.order, function(x) x[order(sub.decomp$u[x,1])]))
            path.order <- order(sub.decomp$v[,1]) #order pathways by PC
            bar.vals <- sub.decomp$u[,1]
            plot.r2 <- pc.r2
            plot.p <- pc.p
            bar.label <- "Eigengene"
        }
        if(order.by == "none"){
            ind.order <- 1:ncol(sub.mat)
            path.order <- 1:nrow(sub.mat)
            
            if(length(has.vals) > 1){ #use the eigenegene if possible
                bar.vals <- sub.decomp$u[,1]
                plot.r2 <- pc.r2
                plot.p <- pc.p
                bar.label = "Eigengene"
            }else{ #otherwise use the means
                bar.vals <- colMeans(sub.mat)
                bar.label = "Mean Expression"
                top.model <- test_effect(mean.val, test.factor)
                plot.r2 <- top.model$r2
                plot.p <- threshold_p(top.model$model.p)
            }
        }

        if(plot.results){

            layout.mat <- matrix(c(1,1,1,1,2,1,1,1,1,2,5,5,5,5,0,6,6,6,7,7,6,6,6,4,4,3,3,3,4,4,3,3,3,4,4), ncol = 7, byrow = FALSE)
            layout(layout.mat, widths = c(1, 1, 0.5, 0.5, 0.5, 0.4), heights = c(rep(0.25, 4), 0.5))
            #layout.show(7)       

            #pane 1 is the heat map for individual values
            par(mar = c(0,label.margin,2,0))
            imageWithText(sub.mat[rev(path.order),ind.order,drop=FALSE], 
                show.text = FALSE, col.names = NULL, row.names = row.names[rev(path.order)],
                row.text.shift = 0.015, 
                col.scale = col.scale, grad.dir = grad.dir,
                split.at.vals = split.at.vals, color.fun = "linear",
                light.dark = "f", global.color.scale = TRUE, global.min = min.val, 
                global.max = max.val)

            mtext(plot.label, side = 3, line = 0)
            plot.dim <- par("usr")    
            color.coord <- segment_region(plot.dim[1], plot.dim[2], nrow(ordered.table))
            coord.dist <- apply(consec_pairs(color.coord), 1, function(x) x[2] - x[1])/2
        
            #pane 2 is a bar chart showing stats for each individual mouse
            #colored by genotype and aligned with the columns of the heat map
            par(mar = c(2,label.margin,0,0))
            if(order.by == "PC" && length(has.vals) <= 1){
                plot.text("Not enough rows to decompose")
            }else{
                barplot(bar.vals[ind.order], col = ordered.table[ind.order,3], names = NA) 
                mtext(bar.label, side = 2, line = 2.5, cex = 0.7)
                #add text for stats
                plot.dim <- par("usr")
                text.x <- fractional_pos(plot.dim[1], plot.dim[2], stat.x)
                r2.y <- fractional_pos(plot.dim[3], plot.dim[4], stat.y)
                p.y <- fractional_pos(plot.dim[3], plot.dim[4], (stat.y-0.1))
                text(text.x, r2.y, bquote(italic(R)^2==.(signif(plot.r2, 2))), adj = 0)
                text(text.x, p.y, labels = plot.p, adj = 0)
            }

            #pane 3 is a decomposition
            par(mar = c(4,4,4,2))
            if(length(has.vals) > 1){
                sub.decomp <- plot.decomp(t(sub.mat), cols = ordered.table[,3], main = "Decomposition", cex = 2)
                pc.order <- order(sub.decomp$u[,1])
            }else{
                plot.text("Not enough rows to decompose")
            }        

            #plot enrichment if requested
            if(plot.enrich){
                enrich <- gost(gsub("*", "", rownames(sub.mat), fixed = TRUE), organism = "mmusculus")
                plot.enrichment(enrich, max.term.size = 3000, num.terms = 20)
            }else{
                #otherwise, plot nothing
                plot.new()
                plot.window(xlim = c(0,1), ylim = c(0,1))
            }

            #pane 4 is color bars for individual gentotypes
            #par(mar = c(2,label.margin,0,0))
            #plot.new()
            #plot.window(xlim = c(plot.dim[1], plot.dim[2]), ylim = c(0,1))
            #for(i in 1:nrow(ordered.table)){
            #    draw.rectangle(color.coord[i]-coord.dist[1], color.coord[i]+coord.dist[1],
            #        0, 1, fill = ordered.table[ind.order[i],3], border = NA)
            #}

  
            #pane 5 is the bar plot of r2 or effect size for each row
            par(mar = c(0,0,2,2))
            if(path.stats == "R2"){
                barplot(ind.r2[path.order], horiz = TRUE, las = 2, xlim = c(0, 0.4), names = NA)
                mtext(bquote(italic(R)^2), side = 1, line = 2.5, cex = 0.8)
                plot.dim <- par("usr")
                segments(x0 = 0, y0 = plot.dim[3], y1 = plot.dim[4])
                #add grid lines
                segments(x0 = seq(0, 0.4, 0.1), y0 = plot.dim[3], y1 = plot.dim[4], 
                    lty = 2, col = "darkgray")
            }
            if(path.stats == "effect.size"){
                barplot(ind.effect[path.order], horiz = TRUE, las = 2, names = NA)
                mtext("Effect Size", side = 1, line = 2.5, cex = 0.8)
                plot.dim <- par("usr")
                #add zero line
                segments(x0 = 0, y0 = plot.dim[3], y1 = plot.dim[4])
                #add grid lines
                segments(x0 = seq(-0.25, 0.25, 0.1), 
                    y0 = plot.dim[3], y1 = plot.dim[4], 
                    lty = 2, col = "darkgray")
            }
            
            #pane 6 is the violin plots
            par(mar = c(4,2,4,2))
            genos <- levels(as.factor(ordered.table[,2]))
            if(order.by == "top.rank"){
                max.idx <- which.max(ind.r2)
                #row.vals <- lapply(genos, function(x) sub.mat[max.idx,which(ordered.table[,2] == x)]) 
                row.vals <- sub.mat[max.idx,]
                plot.label <- names(max.idx)
            }
            if(order.by == "none"){
                max.idx <- nrow(sub.mat)
                #row.vals <- lapply(genos, function(x) sub.mat[max.idx,which(ordered.table[,2] == x)]) 
                row.vals <- sub.mat[max.idx,]
                plot.label <- rownames(sub.mat)[max.idx]
            }
            if(order.by == "PC" || order.by == "genotype"){
                #row.vals <- lapply(genos, function(x) sub.decomp$u[which(ordered.table[,2] == x),1])
                row.vals <- sub.decomp$u[,1]
                plot.label = "Eigengene"
            }
            if(order.by == "means"){
                #row.vals <- lapply(genos, function(x) colMeans(sub.mat[,which(ordered.table[,2] == x)], na.rm = TRUE))
                row.vals <- colMeans(sub.mat, na.rm = TRUE)
                plot.label <- "Expression Means"
            }
            test_effect(row.vals, ordered.factor, plot.result = TRUE, 
                    autoflip.stat.y = TRUE, plot.label = plot.label, 
                    stat.x = stat.x, stat.y = stat.y, 
                    stat.y.spread = stat.y.spread)

            #pane 7 is a legend for the genotype colors
            plot.new()
            plot.window(xlim = c(0,1), ylim = c(0,1))
            legend(0, 0.9, fill = geno.cols, legend = names(geno.cols))
        }

    }#end case for no values
    result <- list("decomp" = sub.decomp, "overall.r2" = pc.r2, 
        "row.effect" = ind.effect, "row.r2" = ind.r2, "row.p" = ind.p)
    invisible(result)
}

merge_mean_mats <- function(mat_list){
    sub.mats <- Reduce("rbind", mat_list)
    inner.names <- lapply(mat_list, rownames)
    outer.names <- lapply(1:length(inner.names), function(x) rep(names(inner.names)[x], length(inner.names[[x]])))
    name.mat <- cbind(unlist(outer.names), unlist(inner.names))
    mat.labels <- apply(name.mat, 1, function(x) paste(x, collapse = " : "))        
    rownames(sub.mats) <- mat.labels
    sub.vals <- sub.mats[which(!is.na(rowMeans(sub.mats))),]
    return(sub.vals)
}

#individuals is a vector of individual names if you only want to plot
#a subset of individuals
gene_vioplot <- function(gene.name, plot.label = "", 
    stat.x = 0.1, stat.y = 0.9, autoflip.stat.y = FALSE, plot.results = TRUE,
    individuals = NULL){

    if(is.null(individuals)){
        ind.idx <- 1:nrow(adj_expr)
    }else{
        ind.idx <- match(individuals, rownames(adj_expr))
    }

    gene.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene.name),"ensembl_gene_id"]
    geno.expr <- lapply(geno.idx, function(x) adj_expr[x,gene.id])
    if(plot.results){
        test_effect(adj_expr[ind.idx,gene.id], test.factor[ind.idx], 
            plot.result = TRUE, stat.x = stat.x, stat.y = stat.y,
            autoflip.stat.y = autoflip.stat.y, plot.label = gene.name)
    }
    invisible(geno.expr)
}

#if inner.term is NULL, a matrix is assumed.
#if it is specified, a list is assumed
#mean.term.vals is a matrix of mean values like mean.k.vals
#or a list, like mean.bd.k.vals, in which case, inner.term
#needs to be specified.
term_vioplot <- function(outer.term, inner.term = NULL, mean.term.vals, 
    stat.x = 0.1, stat.y = 0.2, stat.y.spread = 0.15, autoflip.stat.y = FALSE){
    
    if(is.null(inner.term)){
        term.idx <- which(rownames(mean.term.vals) == outer.term)
        if(length(term.idx) == 0){stop(paste("I can't find", outer.term))}
        term.expr <- lapply(geno.idx, function(x) mean.term.vals[term.idx,x])
        #term.expr <- mean.term.vals[term.idx,]
        plot.label <- outer.term    
    }else{
        #otherwise we have a list
        outer.idx <- which(names(mean.term.vals) == outer.term)
        if(length(outer.idx) == 0){stop(paste("I can't find", outer.term))}
        inner.idx <- which(rownames(mean.term.vals[[outer.idx]]) == inner.term)
        if(length(inner.idx) == 0){stop(paste("I can't find", inner.term))}
        term.expr <- lapply(geno.idx, function(x) mean.term.vals[[outer.idx]][inner.idx,x])
        #term.expr <- mean.term.vals[[outer.idx]][inner.idx,]
        plot.label <- paste(outer.term, inner.term, sep = " : ")
    }
    test_effect(unlist(term.expr), test.factor[unlist(geno.idx)], 
        plot.label = plot.label, stat.y = stat.y, stat.x = stat.x, 
        stat.y.spread = stat.y.spread, plot.results = TRUE)

    invisible(term.expr)
}

#this function looks at the gene expression correlations 
#and tries to determine whether expression means are actually
#a good summary of the group of genes. 
module_expr <- function(geneID, expr.mat){
    common.genes <- intersect(geneID, colnames(expr.mat))
    gene.mat <- expr.mat[,common.genes,drop=FALSE]
    
    gene.means <- colMeans(gene.mat)
    mouse.means <- rowMeans(gene.mat)

    gene.cor <- cor(gene.mat)
    mouse.cor <- cor(t(gene.mat))

    pheatmap(gene.cor)
    pheatmap(mouse.cor)

    mouse.pc <- plot.decomp()
    pheatmap(gene.mat)

    mouse.cols <- sapply(rownames(gene.mat), function(x) geno.cols[covar.table[x,"climb_geno"]])        
    mouse.order <- order(mouse.means)
    gene.order <- order(gene.means) #order the genes by mean expression for better visualization
    
    png(paste0("~/Desktop/", gsub(" ", "_", group.representation), ".png"), width = 10, height = 7, units = "in", res = 300)
    layout(matrix(c(1,2), ncol = 1), heights = c(0.5, 1))
    par(mar = c(0,4,2,2))
    barplot(mouse.means[mouse.order], names = NA, 
        col = mouse.cols[mouse.order])
    par(mar = c(2,4,0,2))
    #imageWithText(t(gene.mat[mouse.order,gene.order]), split.at.vals = TRUE, col.scale = c("blue", "brown"), show.text = FALSE, row.names = NULL)
    #show the module expression for each individual in the same order as the bars
    boxplot(t(gene.mat[mouse.order,]), col = mouse.cols[mouse.order], las = 2)
    dev.off()
}

```


```{r rnd_test, eval = FALSE}
mean.mat <- matrix(NA, ncol = 68, nrow = 100)
for(i in 1:100){
    rnd.genes <- sample(colnames(adj_expr), 100)
    mean.mat[i,] <- gene_mean_mat(geneID = rnd.genes, adj_expr, group.representation)
}
pheatmap(mean.mat)


geneID <- kegg.bd.list[[1]][[1]]
expr.mat <- adj_expr
```

## Biodomains

We first looked at biodomains and KEGG pathways separately
The plots below show the results for Biodomains.

```{r biodomain_means, fig.width = 10, fig.height = 5}
mean.bd.vals <- non_nested_mean_vals(non_nested_gene_list = bd.list, 
    expr.mat = adj_expr, group.representation = group.representation)

bd.result <- plot_mean_bd_k(mean.bd.k.mat = mean.bd.vals, 
    covar.mat = covar.table, plot.results = TRUE, order.by = "PC",
    path.stats = "R2", stat.x = 0.8, stat.y = 0.2)
```

```{r biodomain_r2, fig.width = 8, fig.height = 6}
#quartz(width = 12, height = 6)
par(mar = c(4,12,2,2), mfrow = c(1,2))
barplot(sort(bd.result$row.r2), horiz = TRUE, las = 2, xlab = "Adjusted R2",
    main = "Biodomain R2")
abline(v = 0)
barplot(sort(bd.result$row.effect), horiz = TRUE, las = 2, xlab = "Effect Size",
    main = "Biodomain Effect Sizes")
abline(v = 0)
```

```{r testing, eval = FALSE}

#As the number of genes gets larger, the R2 for the eigengene
#of a random selection seems to converge on about 0.28
#why is it like this?

test.list <- lapply(1:50, function(x) sample(colnames(adj_expr), 50))

mean.test.vals.eig <- non_nested_mean_vals(non_nested_gene_list = test.list, 
    expr.mat = adj_expr, group.representation = "eigengene")

annot_colors <- list("climb_geno" = geno.cols)
pheatmap(cor(mean.test.vals.eig), 
    annotation_row = covar.table[,"climb_geno",drop=FALSE], 
    annotation_colors = annot_colors)

mean.test.vals.means <- non_nested_mean_vals(non_nested_gene_list = test.list, 
    expr.mat = adj_expr, group.representation = "means")

pheatmap(cor(mean.test.vals.means), 
    annotation_row = covar.table[,"climb_geno",drop=FALSE], 
    annotation_colors = annot_colors)

eig.mean.cor <- sapply(1:nrow(mean.test.vals.eig), function(x) cor(mean.test.vals.eig[x,], mean.test.vals.means[x,]))
hist(eig.mean.cor)

bd.result <- plot_mean_bd_k(mean.bd.k.mat = mean.test.vals.eig, 
    covar.mat = covar.table, plot.results = TRUE)

bd.result <- plot_mean_bd_k(mean.bd.k.mat = mean.test.vals.means, 
    covar.mat = covar.table, plot.results = TRUE)

#test.mat <- adj_expr[,intersect(colnames(adj_expr), bd.list[[1]])]
test.mat <- adj_expr[,test.list[[2]]]
pheatmap(cor(test.mat))
#test.decomp <- plot.decomp(test.mat, mean.center = FALSE, scale.col = FALSE)
test.decomp <- plot.decomp(test.mat, mean.center = TRUE, scale.col = TRUE)
#test.decomp <- plot.decomp(t(test.mat), mean.center = TRUE, scale.col = TRUE)
test.eig <- test.decomp$u[,1]
test.means <- rowMeans(test.mat)
plot.with.model(test.eig, test.means)
```

### Biodomain plots {.tabset .tabset-fade .tabset-pills}
The plots below show how well each biodomain separates the genotypes

```{r ind_bd, results = "asis", plot.width = 10, plot.height = 5}
geno.idx <- lapply(names(geno.cols), function(x) which(test.factor == x))
names(geno.idx) <- names(geno.cols)

carrier.idx <- lapply(c("FC", "VS"), function(x) grep(x, covar.table[,"climb_geno"]))
wt.idx <- setdiff(1:nrow(covar.table), unlist(carrier.idx))
carrier.idx <- list("FC" = carrier.idx[[1]], "WT" = wt.idx, "VS" = carrier.idx[[2]])
names(carrier.idx) <- c("FC", "WT", "VS")

#pdf("~/Desktop/biodomains.pdf", width = 7, height = 6)
for(bd in 1:length(bd.list)){
    cat("####", names(bd.list)[bd], "\n")
    test_effect(mean.bd.vals[bd,], test.factor, 
        plot.results = TRUE, plot.label = names(bd.list)[bd],
        autoflip.stat.y = TRUE) 

    cat("\n\n")
}
#dev.off()

```


## Subdomains {.tabset .tabset-fade .tabset-pills}

We also looked at the subdomains. The boxplot below shows the 
distribution of adjusted R2 for the subdomains within each domain. 


```{r subdomains, fig.width = 7, fig.height = 7}
mean.sbd.vals <- nested_mean_vals(nested_gene_list = sub.bd.list, expr.mat = adj_expr, 
    organization = "inner", group.representation = group.representation)

sbd.result <- lapply(mean.sbd.vals, function(x) if(length(x) > 0){plot_mean_bd_k(x, 
    covar.mat = covar.table, plot.results = FALSE)}else{NA})

sbd.r2 <- lapply(sbd.result, function(x) if(length(x) > 1){x$row.r2}else{NA})
names(sbd.r2) <- names(sub.bd.list)

#path.order <- order(sapply(sbd.r2, function(x) if(length(x) > 0){mean(x, na.rm = TRUE)})) #by biodomain mean
path.order <- order(bd.result$row.r2) #by overall biodomain r2
par(mar = c(4,16,2,2))
boxplot(sbd.r2[path.order], las = 2, horizontal = TRUE, 
    xlab = substitute(paste("Association (", R^2, ")")))
abline(v = seq(0, 0.3, 0.1), lty = 2, col = "darkgray")
points(x = bd.result$row.r2[path.order], y = 1:length(path.order), col = "blue",
    pch = 16)

```

```{r subdomain_overview_fig}
pdf(here("Results", "for_paper", "Subomain_overview.pdf"), width = 7, height = 7)
par(mar = c(4,16,2,2))
boxplot(sbd.r2[path.order], las = 2, horizontal = TRUE, 
    xlab = substitute(paste("Association (", R^2, ")")))
abline(v = seq(0, 0.3, 0.1), lty = 2, col = "darkgray")
points(x = bd.result$row.r2[path.order], y = 1:length(path.order), col = "blue",
    pch = 16)
dev.off()
```


### Subdomain bar plots {.tabset .tabset-fade .tabset-pills}

The bar plots below shows the R^2 values within each biodomain.

```{r top_sub_r2, fig.width = 10, fig.height = 7, results = "asis"}
#pdf("~/Desktop/subdomain_r2.pdf", width = 10, height = 7)
max.r2 <- max(unlist(sbd.r2), na.rm = TRUE)
for(bd in 1:length(sbd.r2)){
    if(length(sbd.r2[[bd]]) > 1){
        cat("####", names(sbd.r2)[bd], "\n")
        par(mar = c(4,30,2,2))
        r2.vals <- sbd.r2[[bd]]
        r2.vals[which(r2.vals < 0)] <- 0
        barplot(sort(r2.vals), horiz = TRUE, las = 2, xlab = "Adjusted R2",
            main = names(sbd.r2)[bd], xlim = c(0, max.r2))
        abline(v = seq(0, max.r2, 0.1), lty = 2, col = "darkgray")
        cat("\n\n")
    }
}
#dev.off()
```

#### Overall

The plot below shows the top subdomains overall

```{r top_sbd_r2, fig.width = 10, fig.height = 8}
all.sub.r2 <- unlist(sbd.r2)
#hist(all.sub.r2, breaks = 25)
big.r2 <- which(all.sub.r2 >= 0.15)

#pdf("~/Desktop/top_r2.pdf", width = 10, height = 8)
par(mar = c(4,35,2,2))
barplot(sort(all.sub.r2[big.r2]), horiz = TRUE, las = 2)
abline(v = seq(0, max(all.sub.r2, na.rm = TRUE), 0.1), lty = 2)
#dev.off()
```


### Subdomain violin plots {.tabset .tabset-fade .tabset-pills}
The plots below show how well each subdomain separates the genotypes

```{r ind_sbd, results = "asis", plot.width = 7, plot.height = 5}

#pdf("~/Desktop/subdomains.pdf", width = 7, height = 5)
for(bd in 1:length(sub.bd.list)){
    cat("####", names(sub.bd.list)[bd], "{.tabset .tabset-fade .tabset-pills}\n")
    if(length(sub.bd.list[[bd]]) > 0){  
        for(s in 1:length(sub.bd.list[[bd]])){
            cat("#####", names(sub.bd.list[[bd]])[s], "\n")  
            geno.vals <- lapply(geno.idx, function(x) mean.sbd.vals[[bd]][s,x])
            geno.order <- order(sapply(geno.vals, mean))
            test_effect(unlist(geno.vals), test.factor, 
                plot.results = TRUE, stat.y = 0.9, plot.label = names(sub.bd.list)[bd],
                autoflip.stat.y = TRUE)
            cat("\n\n")
        }
    }
    cat("\n\n")
}
#dev.off()
```

```{r subdomain_example_fig}
#specify which subdomains to plot
to.plot <- c("Mitochondrial Metabolism" = 
    c("proton motive force-driven mitochondrial ATP synthesis"),
    "Oxidative Stress" = c("response to oxidative stress"),
    "Synapse" = c("presynapse organization"))


pdf(here("Results", "for_paper", "subdomains.pdf"), width = 4, height = 4)
for(i in 1:length(to.plot)){
    bd.idx <- which(names(sub.bd.list) == names(to.plot)[i])
    for(j in 1:length(to.plot[[i]])){
        sbd.idx <- which(names(sub.bd.list[[bd.idx]]) == to.plot[[i]][j])
        sbd.vals <- mean.sbd.vals[[bd.idx]][sbd.idx,]
        stats <- test_effect(sbd.vals, test.factor, plot.results = TRUE,
            stat.y = 0.8, autoflip.stat.y = TRUE, plot.label = to.plot[[i]][j],
            stat.y.spread = 0.2)
    }
}
dev.off()
```

### Subdomain Heatmaps {.tabset .tabset-fade .tabset-pills}

For each subdomain, we calculated the mean expression across the 
genotypes. The plots below show these means grouped by biodomain.

```{r sub_heat, results = "asis", fig.width = 12, fig.height = 5}
#pdf("~/Desktop/sub_plots.pdf", width = 12, height = 5)
sd.global.min <- min(unlist(mean.sbd.vals), na.rm = TRUE)
sd.global.max <- max(unlist(mean.sbd.vals), na.rm = TRUE)
for(bd in 1:length(mean.sbd.vals)){
    if(length(mean.sbd.vals[[bd]]) > 0){
        cat("####", names(sub.bd.list)[bd], "\n")
        plot_mean_bd_k(mean.bd.k.mat = mean.sbd.vals[[bd]], covar.mat = covar.table,
            label.margin = 24, global.min = sd.global.min, 
            order.by = "PC", global.max = sd.global.max, path.stats = "effect.size")
        cat("\n\n")
    }
}
#dev.off()
```

### Subdomain overview

```{r bd_overview_heat}
bd.r2 <- bd.result$row.r2
bd.r2[which(bd.r2 < 0)] <- 0 #set a floor of 0
bd.mean.mat <- matrix(NA, nrow = length(bd.r2), ncol = length(geno.cols))
colnames(bd.mean.mat) <- names(geno.cols)
rownames(bd.mean.mat) <- names(bd.r2)
for(bd in 1:length(bd.r2)){
    geno.vals <- lapply(geno.idx, function(x) mean.bd.vals[bd,x])
    bd.mean.mat[bd,] <- sapply(geno.vals, mean)
}

bd.order <- order(bd.r2, decreasing = TRUE)
png(here("Results", "for_paper", "Biodomain_overview.png"), width = 6, height = 5, units = "in", res = 300)
layout.mat <- matrix(c(1:3), nrow = 1)
layout(layout.mat, widths = c(0.7, 0.3, 0.25))
par(mar = c(4,15,2,0), bg = NA)
imageWithText(signif(bd.mean.mat[bd.order,ordered.geno], 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", col.text.shift = 0.05,
    row.text.shift = 0.2, show.text = FALSE, row.text.cex = 1.2, col.text.rotation = 0,
    col.text.adj = 0.5)
par(mar = c(4,0,1.5,2))
barplot(rev(bd.r2[bd.order]), horiz = TRUE, names = NA, xlab = "", 
    xlim = c(0, 0.2))
mtext(bquote(italic(R)^2), side = 1, line = 2.5)
plot.dim <- par("usr")
segments(x0 = seq(0, 0.2, 0.05), y0 = plot.dim[3], y1 = plot.dim[4], col = "darkgray", lty = 2)
par(mar = c(20,4,2,3)) 
imageWithTextColorbar(signif(bd.mean.mat, 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1)
plot.dim <- par("usr")
plot.width <- plot.dim[2] - plot.dim[1]
text(x = (plot.dim[1]-(plot.width*3)), y = mean(plot.dim[3:4]), 
    labels = "Expression (A.U.)", srt = 90, cex = 1.2)
dev.off()
```


```{r sig_subdomain_heat, eval = FALSE}
#I tried making a heat map of the significant subdomains (FDR < 0.1)
#and they don't look like much. I don't think this view is helpful.

sbd.p <- lapply(sbd.result, function(x) if(length(x) > 1){x$row.p}else{NA})
names(sbd.p) <- names(sub.bd.list)
sbd.fdr  <- p.adjust(unlist(sbd.p), "fdr")
sig.sbd <- which(sbd.fdr <= 0.1)
sig.p <- unlist(sbd.p)[sig.sbd]

sbd.mean.mat <- matrix(NA, nrow = length(sig.sbd), ncol = length(geno.cols))
colnames(sbd.mean.mat) <- names(geno.cols)
rownames(sbd.mean.mat) <- names(sig.sbd)
for(sbd in 1:length(sig.sbd)){
    split.name <- strsplit(names(sig.sbd)[sbd], ".", fixed = TRUE)[[1]]
    bd.name <- split.name[1] 
    sbd.name <- split.name[2]
    bd.idx <- which(names(sub.bd.list) == bd.name)
    sbd.idx <- which(names(sub.bd.list[[bd.idx]]) == sbd.name)
    geno.vals <- lapply(geno.idx, function(x) mean.sbd.vals[[bd.idx]][sbd.idx,x])
    sbd.mean.mat[sbd,] <- sapply(geno.vals, mean)
}

sbd.decomp <- plot.decomp(sbd.mean.mat, plot.results = FALSE)
pc.order <- order(sbd.decomp$u[,1])
p.order <- order(sig.p, decreasing = FALSE)

png("~/Desktop/sub_bd_overview.png", width = 9, height = 12, units = "in", res = 300)
#png(here("Results", "for_paper", "Biosubdomain_overview.png"), width = 9, height = 5, units = "in", res = 300)
layout.mat <- matrix(c(1:3), nrow = 1)
layout(layout.mat, widths = c(1, 0.3, 0.3))
par(mar = c(4,30,2,0), bg = NA)
imageWithText(signif(sbd.mean.mat[pc.order,ordered.geno], 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", col.text.shift = 0.03,
    row.text.shift = 0.15, show.text = FALSE, row.text.cex = 1.2)
par(mar = c(4,0,2,2))
barplot(rev(-log10(sig.p[pc.order])), horiz = TRUE, names = NA, 
    xlab = substitute(paste("-log"[10], "(p)")))
plot.dim <- par("usr")
segments(x0 = -log10(0.05/length(sbd.p)), y0 = plot.dim[3], y1 = plot.dim[4], col = "red", lty = 2)
par(mar = c(20,4,2,3)) 
imageWithTextColorbar(signif(sbd.mean.mat, 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1)
plot.dim <- par("usr")
plot.width <- plot.dim[2] - plot.dim[1]
text(x = (plot.dim[1]-(plot.width*3)), y = mean(plot.dim[3:4]), 
    labels = "Expression (A.U.)", srt = 90, cex = 1.2)
dev.off()
```

## KEGG pathways

The plots below show results for KEGG pathways.
Because there are so many KEGG pathways, the bar plot only 
shows the top 20 results.

```{r kegg, fig.width = 7, fig.height = 9}

mean.k.vals <- non_nested_mean_vals(kegg.list, expr.mat = adj_expr, 
    group.representation = group.representation)

k.result <- plot_mean_bd_k(mean.bd.k.mat = mean.k.vals, 
    covar.mat = covar.table, plot.results = FALSE)

k.adj.p <- p.adjust(k.result$row.p, "bonferroni")
sig.k <- which(k.adj.p < 0.1)

par(mar = c(4,25,2,2))
barplot(sort(k.result$row.r2[sig.k]), horiz = TRUE, las = 2, xlab = "Adjusted R2",
    main = "KEGG pathways")
```


```{r sig_kegg_overview}

k.order <- order(k.result$row.r2[sig.k], decreasing = TRUE)
ordered.k.p <- k.adj.p[sig.k[k.order]]
k.mean.mat <- matrix(NA, nrow = length(sig.k), ncol = length(geno.cols))
colnames(k.mean.mat) <- names(geno.cols)
rownames(k.mean.mat) <- names(ordered.k.p)
for(k in 1:length(sig.k)){
    geno.vals <- lapply(geno.idx, function(x) mean.k.vals[names(ordered.k.p)[k],x])
    k.mean.mat[k,] <- sapply(geno.vals, mean)
}

k.mean.decomp <- plot.decomp(k.mean.mat, plot.results = FALSE)
pc.order <- order(k.mean.decomp$u[,1])

cat.cols <- read.delim(here("Data", "general", "kegg_colors.txt"), comment.char = "!", sep = "\t")
kegg.cat <- read.delim(here("Data", "general", "kegg_categories.txt"), comment.char = "#", sep = "\t")

png(here("Results", "for_paper", "KEGG_overview.png"), width = 8.5, height = 5, units = "in", res = 300)
#quartz(width = 8, height = 5)
layout(matrix(c(1,2,3,1,2,4), nrow = 2, byrow = TRUE), widths = c(1.2, 0.3, 0.5))
par(mar = c(4,26,2,0), bg = NA)
imageWithText(signif(k.mean.mat[pc.order,ordered.geno], 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", col.text.shift = 0.03,
    row.text.shift = 0.15, show.text = FALSE, row.text.cex = 1.2)

#color KEGG pathways by category
plot.dim <- par("usr")
plot.width <- plot.dim[2] - plot.dim[1]
max.x <- plot.dim[1]
rect.height <- 0.5

#squish the rectangle width - we want short rectangles longer
#and long rectangles shorter by just a bit
path.len <- sapply(kegg.cat[,1], nchar)
len.scale <- 1/scale.between.vals(path.len, 0.7, 1.1)
min.x <- (max.x - (path.len/plot.width)*len.scale)

#draw on rectangles
for(i in 1:nrow(kegg.cat)){
    path.name <- kegg.cat[i,1]
    path.cat <- kegg.cat[i,2]
    path.col <- add_alpha(cat.cols[which(cat.cols[,1] == path.cat),2], 0.5)
    path.rgb <- col2rgb(path.col)
    path.idx <- plot.dim[4] - which(rownames(k.mean.mat)[pc.order] == path.name)
    
    #draw.rectangle(min.x[i], max.x, path.idx-rect.height, path.idx+rect.height, 
    #    fill = rgb(path.rgb[1,1]/256, path.rgb[2,1]/256, path.rgb[3,1]/256, alpha = 0.5), 
    #    border = NA)

    draw.rectangle(min.x[i], max.x, path.idx-rect.height, path.idx+rect.height, 
        fill = path.col, border = NA)

}

#add -log10(p) bars alongside heat map
par(mar = c(4,0,2,0))
barplot(rev(-log10(k.result$row.p[sig.k[k.order[pc.order]]])), horiz = TRUE, 
    names = NA, xlab = substitute(paste("-log"[10], "(p)")))
plot.dim <- par("usr")
segments(x0 = -log10(0.1/length(k.result$row.p)), y0 = plot.dim[3], 
    y1 = plot.dim[4], col = "red", lty = 2)

#add a legend for the categories
par(mar = c(4,0,2,0))
cat.len <- nchar(cat.cols[,1])
scale.factor <- scale.between.vals(cat.len, 0.97, 1.03)
cat.order <- order(cat.len, decreasing = TRUE)
plot.new()
plot.window(xlim = c(0, 1), ylim = c(0, 1))
y.pos <- segment_region(0.65, 0.35, length(cat.len), "ends")
x.max <- rev(0.5 + 2/(cat.len[cat.order]*scale.factor[cat.order]))
x.min <- rev(0.5 - 2/(cat.len[cat.order]*scale.factor[cat.order]))
for(i in 1:length(cat.len)){
    draw.rectangle(x.min[i], x.max[i], y.pos[i]-0.05, y.pos[i]+0.05, 
        fill = add_alpha(cat.cols[cat.order[i],2], 0.5), border = NA)
    text(x = 0.5, y = y.pos[i], labels = cat.cols[cat.order[i],1], cex = 0.7)
}


#add a color bar for the heat map
par(mar = c(4,6,2,7)) 
imageWithTextColorbar(signif(k.mean.mat, 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1.2)
plot.dim <- par("usr")
plot.width <- plot.dim[2] - plot.dim[1]
text(x = (plot.dim[2]+(plot.width*0.4)), y = mean(plot.dim[3:4]), 
    labels = "Expression (A.U.)", srt = 270, cex = 1.2)
dev.off()
```

### KEGG plots {.tabset .tabset-fade .tabset-pills}
The plots below show how well each significant KEGG 
pathway separates the genotypes.

```{r ind_kegg, results = "asis", plot.width = 10, plot.height = 5}
#pdf("~/Desktop/kegg.pdf", width = 7, height = 5)
kegg.mean.mat <- matrix(NA, nrow = length(ordered.k.p), ncol = length(geno.cols))
rownames(kegg.mean.mat) <- names(ordered.k.p)
colnames(kegg.mean.mat) <- names(geno.cols)
for(k in 1:length(ordered.k.p)){
    cat("####", names(ordered.k.p)[k], "\n")
    geno.vals <- lapply(geno.idx, function(x) mean.k.vals[names(ordered.k.p)[k],x])
    stats <- test_effect(mean.k.vals[names(ordered.k.p)[k],], test.factor,
        plot.result = TRUE, autoflip.stat.y = TRUE, plot.label = names(ordered.k.p)[k])

    kegg.mean.mat[k,] <- sapply(geno.vals, mean)
    cat("\n\n")
}
#dev.off()

#kegg.decomp <- plot.decomp(kegg.mean.mat, plot.result = FALSE)
#row.order <- order(kegg.decomp$u[,1])
#imageWithText(signif(kegg.mean.mat[row.order,ordered.geno], 2), split.at.vals = TRUE, 
#    col.scale = c("blue", "brown"), grad.dir = "ends", col.text.shift = 0.03,
#    row.text.shift = 0.15, show.text = FALSE, row.text.cex = 1.2)
```


```{r kegg_violin_for_paper}
#we want to highlight a couple examples in the paper
example.path <- c("Ribosome", "Proteasome")
pdf(here("Results", "for_paper", "KEGG_expression_examples.pdf"), width = 4, height = 4)
for(i in 1:length(example.path)){    
    geno.vals <- lapply(geno.idx, function(x) mean.k.vals[example.path[i],x])
    #geno.order <- order(sapply(geno.vals, mean))
    model <- test_effect(mean.k.vals[example.path[i],], test.factor,
        plot.result = TRUE, autoflip.stat.y = TRUE, 
        plot.label = example.path[i], stat.y.spread = 0.2)

}
dev.off()


```

### KEGG overview


The plot below gives an overview of the expression of the top KEGG pathways.

```{r top_kegg_overview, fig.width = 11, fig.height = 9}
mean.decomp <- plot.decomp(t(kegg.mean.mat), label.points = TRUE, plot.results = FALSE)
row.order <- order(mean.decomp$v[,1])
#png("~/Desktop/kegg_mean.png", width = 11, height = 7, units = "in", res = 300)
layout.mat <- matrix(c(1,2), nrow = 1)
layout(layout.mat, widths = c(1, 0.2))
par(mar = c(4,25,2,2))
imageWithText(signif(kegg.mean.mat[row.order,ordered.geno], 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", col.text.shift = 0.03,
    row.text.shift = 0.15)
par(mar = c(20,4,2,4)) 
imageWithTextColorbar(signif(kegg.mean.mat[row.order,ordered.geno], 2), split.at.vals = TRUE, 
    col.scale = c("blue", "brown"), grad.dir = "ends", cex = 1)
#dev.off()
```

```{r intersect_vals}
#calculate mean gene expression for a given gene list
mean.bd.k.file <- file.path(results.dir, paste0("KEGG_BD_individual_expression_", group.representation, ".RDS"))
if(!file.exists(mean.bd.k.file)){
    mean.bd.k.vals <- nested_mean_vals(nested_gene_list = kegg.bd.list, 
        expr.mat = adj_expr, "outer", group.representation = group.representation)
    saveRDS(mean.bd.k.vals, mean.bd.k.file)
}else{
    mean.bd.k.vals <- readRDS(mean.bd.k.file)
}
```

```{r plot_mats}

min.val <- min(unlist(mean.bd.k.vals), na.rm = TRUE)
max.val <- max(unlist(mean.bd.k.vals), na.rm = TRUE)

kegg.plot.dir <- file.path(results.dir, "KEGG_plots")

all.bd.k.result <- vector(mode = "list", length = length(mean.bd.k.vals))
names(all.bd.k.result) <- names(mean.bd.k.vals)
pdf(file.path(kegg.plot.dir, paste0("kegg_bd_intersections_individuals_", group.representation, ".pdf")), width = 15, height = 7)
hist(unlist(mean.bd.k.vals), xlab = "Mean Value", main = "Mean Biodomain-Kegg Intersection Expression")
for(i in 1:length(mean.bd.k.vals)){
  if(length(mean.bd.k.vals[[i]]) > 0){
    all.bd.k.result[[i]] <- plot_mean_bd_k(mean.bd.k.mat = mean.bd.k.vals[[i]], 
    covar.mat = covar.table, plot.label = names(mean.bd.k.vals)[i], order.by = "PC",
    path.stats = "R2")
  }
}
dev.off()
```


```{r eval = FALSE}
all.r2 <- lapply(all.bd.k.result, function(x) x$row.r2)
#which.max(unlist(all.r2))
```

## Stacked intersections

All intersections for all individuals are shown below.
This matrix does tend to separate the FC and VS 
genotypes from each other.

```{r merge_mats, fig.width = 10, fig.height = 5}

sub.vals <- merge_mean_mats(mean.bd.k.vals)
#png("~/Desktop/all_intersections.png", width = 10, height = 5, units = "in", res = 300);par(bg = NA)
sub.val.result <- plot_mean_bd_k(mean.bd.k.mat = sub.vals, 
    covar.mat = covar.table, row.names = NULL, order.by = "PC",
    stat.x = 0.1, stat.y = 0.9, path.stats = "R2", stat.y.spread = 0.2)
#dev.off()
#barplot(cl.width, col = geno.cols)
```

The plot below shows that this separation is statistically 
significant along the first principal component of the matrix.

```{r test_sep}
sub.decomp <- plot.decomp(sub.vals, plot.results = FALSE, pc = length(geno.cols))
ind.vals <- sub.decomp$v[,1] #use the loadings on the individuals
test.pc  <- test_effect(ind.vals, test.factor, plot.result = TRUE)
```


We did permutations to verify that this p value is drawn from 
a uniform distribution. We shuffled the individual labels and
recalculated the ANOVA. The plot below shows the qq plot of the
p value distribution compared to a uniform distribution.

```{r ind_perm}

rnd.p <- rep(NA, 1000)
for(p in 1:1000){
    rnd.sample <- sample(1:ncol(sub.vals))
    test.pc  <- test_effect(sample(ind.vals), test.factor)
    rnd.p[p] <- test.pc$model.p
}

qqunif.plot(rnd.p)
```


## Pathway selection

There are a couple ways we can pick top pathway intersections. 
We can either look at the most extreme intersections based on
the first principal component of the full matrix. This gives 
us the intersections that are most representative of the 
overall variation in the matrix. 

Alternatively, we can select pathways based on how much 
of their individual variance is explained by genotype (R2).
These may not necessarily represent the matrix overall,
but are independently (and significantly) associated
with genotype.

In the following code we select either by R-squared 
or by PC loading. This can be toggled in the code.

When we select pathways by R-squared we get the pathways
that are independetly most strongly associated with genotype
regardless of the pattern of expression. We selected 
intersections that were significant with an FDR of `path.fdr.thresh`.

We can then divide these intersections into those that 
have a negative loading and those that have a positive
loading. Intersections with negative loadings were 
downregulated in VS relative to FC, and those with 
positive loadings were upregulated in VS releative to
FC.


```{r sig_intersections}
pc.vals <- sub.val.result$decomp$v[,1]

if(select_by == "R2"){
    #high.thresh <- get.percentile(sub.val.result$row.r2, 98)
    #sig.idx <- which(sub.val.result$row.r2 >= high.thresh)
    sig.idx <- which(p.adjust(sub.val.result$row.p, "fdr") <= path.fdr.thresh)
}
if(select_by == "PC"){
    high.thresh <- get.percentile(pc.vals, 99)
    low.thresh <- get.percentile(pc.vals, 1)
    #hist(pc.vals, breaks = 50);abline(v = c(high.thresh, low.thresh), col = "red")
    sig.idx <- union(which(pc.vals >= high.thresh), which(pc.vals <= low.thresh))
    sig.col <- rep("black", length(pc.vals))
    sig.col[sig.idx] <- "blue"
    #plot(pc.vals, col = sig.col);abline(h = c(high.thresh, low.thresh))
}

#division by PC loading sign
neg.idx <- which(pc.vals < 0)
pos.idx <- which(pc.vals > 0)

neg.sig <- intersect(sig.idx, neg.idx)
pos.sig <- intersect(sig.idx, pos.idx)
```

There were `r length(sig.idx)` significant pathway intersections
at this significance level. There were `r length(neg.sig)` 
intersections with negative PC1 loadings, and `r length(pos.sig)`
pathways with positive PC1 loadings.

The plot below shows the PC1 loading and the genetic R2
for each pathway intersection. Blue dots are significant
and have a negative PC1 loading. Brown dots are significant
and have a positive PC1 loading.

```{r, plot_pc_r2}
pt.col <- rep("black", length(pc.vals))
pt.col[neg.sig] <- "blue"
pt.col[pos.sig] <- "brown"

plot(sub.val.result$decomp$v[,1], sub.val.result$row.r2, 
    col = pt.col, pch = 16, xlab = "PC1", ylab = bquote(italic(R)^2),
    main = "Significant Pathway Intersections")
abline(v = 0)
#abline(v = c(high.thresh, low.thresh))
```

A full image of these pathways is shown below. The rows and 
columns are ordered by the first PC to show that this groups
the pathways into those that are up vs. down in the VS and FC
carriers.

The example pathway is the pathway with the most extreme
PC loading at one end.

```{r high_path, fig.width = 10, fig.height = 5}
sig.path <- sub.vals[c(neg.sig, pos.sig),]
path.order <- order(plot.decomp(sig.path, plot.results = FALSE)$u[,1])
ind.order <- order(plot.decomp(sig.path, plot.results = FALSE)$v[,1])
top.path.result <- plot_mean_bd_k(mean.bd.k.mat = sig.path[path.order,ind.order], 
    covar.mat = covar.table, label.margin = 4, order.by = "none",
    row.names = NULL)
```

The figure below shows the expression means for each genotype
for each of these pathway intersections.

```{r mean_sep, fig.width = 7, fig.height = 12}

geno.mats <- lapply(geno.idx, function(x) sig.path[,x])
geno.means <- sapply(geno.mats, rowMeans)

#png("~/Desktop/top_paths.png", width = 7, height = 30, units = "in", res = 300)
par(mar = c(4,20,2,2))
imageWithText(geno.means[rev(path.order),ordered.geno], show.text = FALSE, 
    split.at.vals = TRUE, col.scale = c("blue", "brown"),
    grad.dir = "ends", col.text.shift = 0.02, row.text.cex = 0.7, row.text.shift = 0.15)
#dev.off()

#imageWithTextColorbar(geno.means, split.at.vals = TRUE, col.scale = c("blue", "brown"),
#    grad.dir = "ends", cex = 1)
```

```{r example_fig, eval = FALSE}

png("~/Desktop/example_top.png", width = 6, height = 7, units = "in", res = 300)
top.idx <- c(head(rev(path.order), 10), tail(rev(path.order), 10))
par(mar = c(4,22,2,2), bg = NA)
imageWithText(geno.means[top.idx,ordered.geno], show.text = FALSE, 
    split.at.vals = TRUE, col.scale = c("blue", "brown"),
    grad.dir = "ends", col.text.shift = 0.05, row.text.cex = 0.7, 
    row.text.shift = 0.28, col.text.rotation = 0, col.text.adj = 0.5)
dev.off()

split.ex <- strsplit(rownames(geno.means)[top.idx], " : ")
ex.kegg <- sapply(split.ex, function(x) x[1])
ex.bd <- sapply(split.ex, function(x) x[2])
cat(ex.kegg, sep = "\n")
cat(ex.bd, sep = "\n")
```

The decomposition below shows very nice separation of the genotypes.

```{r mean_decomp, fig.width = 5, fig.height = 5}
mean.decomp <- plot.decomp(t(geno.means), label.points = TRUE, 
    cols = geno.cols, cex = 1.5)
```


## Term networks

We built networks between biodomains and kegg pathways based
on the pathway intersections that passed the threshold. We 
made one for the positive pathways (up in FC) and one for
the negative pathways (down in FC).

Node size is relative to the degree of the node. I realize 
that this isn't all that meaninful since the interactions 
can be a bit redundant. I'm working on developing a better 
system.

The edge color and width indicates the percent variance 
explained by genotype for the genes in that interaction.

```{r nets, fig.width = 25, fig.height = 25}


build_net <- function(edge.names){

    split.names <- strsplit(edge.names, " : ")
    net.kegg <- sapply(split.names, function(x) x[1])
    net.bd <- sapply(split.names, function(x) x[2])

    net <- graph_from_edgelist(cbind(net.bd, net.kegg), directed = FALSE)
    v.col <- rep("#7fc97f", vcount(net))
    v.col[which(V(net)$name %in% names(bd.list))] <- "#beaed4"
    
    V(net)$vertex.color <- v.col
    return(net)
}    


#pdf("~/Desktop/net.pdf", width = 25, height = 25)
high.net <- build_net(edge.names = rownames(sub.vals)[pos.sig])
high.deg <- degree(high.net)
high.r2 <- sub.val.result$row.r2[pos.sig]
high.pc <- sub.val.result$decomp$v[pos.sig,1]
e.val <- high.pc #assign edge vals to either R2 or PC loading
ecol <- colors.from.values(e.val, col.scale = "blue", grad.dir = "high")
plot(high.net, vertex.color = V(high.net)$vertex.color, 
    vertex.size = scale.between.vals(high.deg*3, 2, 20),
    layout = layout_nicely, main = "Positive Pathways", edge.width = e.val*200,
    edge.color = ecol, vertex.label.cex = scale.between.vals(high.deg/2, 1, 3))


low.net <- build_net(edge.names = rownames(sub.vals)[neg.sig])
low.deg <- degree(low.net)
low.r2 <- sub.val.result$row.r2[neg.sig]
low.pc <- sub.val.result$decomp$v[neg.sig,1]
e.val <- abs(low.pc) #assign edge vals to either R2 or PC loading
ecol <- colors.from.values(e.val, col.scale = "blue", grad.dir = "high")
plot(low.net, vertex.color = V(low.net)$vertex.color, 
    vertex.size = scale.between.vals(low.deg*3, 2, 20),
    layout = layout_nicely, main = "Negative Pathways", edge.width = e.val*200,
    edge.color = ecol, vertex.label.cex = scale.between.vals(low.deg/2, 1, 3))

#dev.off()

```

```{r test, eval = FALSE}
#If we use just PC1 as the selection criterion,
#we get more pathway intersections in the low R2
#region, and we miss quite a few with high R2.
#The intersections with APP in them have high loadings,
#but relatively low R2, so we see a much stronger 
#APP signal if we use this selection criterion.
#What does this mean about APP signaling in these 
#mice? It is definitely there, but it is not as
#dominant as I had originall thought. 
#selecting for R2 makes a much bigger network and
#ones that are dominated by lipid metabolism,
#metal binding, and oxidative stress.

low.thresh <- get.percentile(sub.decomp$u[,1], 1)
high.thresh <- get.percentile(sub.decomp$u[,1], 99)
neg.sig <- which(sub.decomp$u[,1] < low.thresh)
pos.sig <- which(sub.decomp$u[,1] > high.thresh)
#length(low.idx)
#length(high.idx)

pt.col <- rep("black", nrow(sub.decomp$u))
pt.col[neg.sig] <- "blue"
pt.col[pos.sig] <- "brown"

#dots for R2 and PC1
plot(sub.decomp$u[,1], sub.val.result$row.r2, col = pt.col, pch = 16, xlab = "PC1", ylab = "R2",
    main = "Selected Pathway Intersections")
abline(v = 0)

#full path picture
sig.path <- sub.vals[c(neg.sig, pos.sig),]
path.order <- order(plot.decomp(sig.path, plot.results = FALSE)$u[,1])
ind.order <- order(plot.decomp(sig.path, plot.results = FALSE)$v[,1])
top.path.result <- plot_mean_bd_k(sig.path[path.order,ind.order], covar.table, 
    label.margin = 20, order.by = "none")

#networks
high.net <- build_net(edge.names = rownames(sub.vals)[pos.sig])
high.deg <- degree(high.net)
high.r2 <- sub.val.result$row.r2[pos.sig]
ecol <- colors.from.values(high.r2, col.scale = "blue", grad.dir = "high")
plot(high.net, vertex.color = V(high.net)$vertex.color, 
    vertex.size = scale.between.vals(high.deg*3, 5, 40),
    layout = layout_nicely, main = "Positive Pathways", edge.width = high.r2*20,
    edge.color = ecol, vertex.label.cex = scale.between.vals(high.deg/2, 1, 3))


low.net <- build_net(edge.names = rownames(sub.vals)[neg.sig])
low.deg <- degree(low.net)
low.r2 <- sub.val.result$row.r2[neg.sig]
ecol <- colors.from.values(low.r2, col.scale = "blue", grad.dir = "high")
plot(low.net, vertex.color = V(low.net)$vertex.color, 
    vertex.size = scale.between.vals(low.deg*3, 5, 40),
    layout = layout_nicely, main = "Negative Pathways", edge.width = low.r2*20,
    edge.color = ecol, vertex.label.cex = scale.between.vals(low.deg/2, 1, 3))

#dev.off()
```


##  Individual genes in intersections

We looked more closely at individual intersections to get
a better look at how the genes in there are expressed
across the genotypes.

```{r individ_fun}

plot_individual_genes <- function(intersection.name = NULL, gene.list = NULL, 
    plot.type = c("individual", "means", "boxes"), plot.label = "",
    label.margin = 4, order.by = c("PC", "top.rank", "mean", "genotype", "none"), 
    show.text = TRUE, legend.x = NULL, legend.y = NULL, stat.x = 0.1, stat.y = 0.9, 
    return.full.result = FALSE, plot.enrich = FALSE){

    order.by = order.by[1]
    plot.type = plot.type[1]
    if(is.null(intersection.name) && is.null(gene.list)){stop("At least one of intersection.name or gene.list must be specified")}

    if(is.null(gene.list)){
        split.name <- strsplit(intersection.name, " : ")
        k.name <- split.name[[1]][1]
        bd.name <- split.name[[1]][2]
        bd.idx <- which(names(kegg.bd.list) == bd.name)
        k.idx <- which(names(kegg.bd.list[[bd.idx]]) == k.name)
        term.genes <- kegg.bd.list[[bd.idx]][[k.idx]]
        plot.label <- intersection.name
    }else{
        term.genes <- gene.list
    }
    common.genes <- intersect(term.genes, colnames(adj_expr))

    if(length(common.genes) == 0){
        plot.text(paste("Cannot find genes for", intersection.name))
    }

    term.expr <- adj_expr[,common.genes,drop=FALSE]
    gene.names <- mouse.genes[match(common.genes, mouse.genes[,"ensembl_gene_id"]), "external_gene_name"]

    #see if any are in our list of AD genes
    is_ad  <- which(gene.names %in% ad.genes[,1])
    ad.mark <- rep("", length(gene.names))
    ad.mark[is_ad] <- "**"
    gene.names <- paste(ad.mark, gene.names, ad.mark, sep = "")
    colnames(term.expr) <- gene.names

    gene.means <- sapply(geno.idx, function(x) term.expr[x,,drop=FALSE])

    if(ncol(gene.means[[1]]) > 1){    
        mean.mat <- sapply(gene.means, colMeans)
        #plot.decomp(mean.mat, label.points = TRUE)
        gene.decomp <- plot.decomp(mean.mat, plot.results = FALSE)
        gene.order <- order(gene.decomp$u[,1])
    }else{
        mean.mat <- sapply(gene.means, colMeans)
        mean.mat <- matrix(mean.mat, nrow = 1)
        gene.order = 1
    }
    
    if(plot.type == "individual"){
        full.result <- plot_mean_bd_k(mean.bd.k.mat = t(term.expr[,gene.order,drop=FALSE]), 
            covar.mat = covar.table, plot.label = plot.label, 
            label.margin = label.margin, order.by = order.by, 
            stat.x = stat.x, stat.y = stat.y, plot.enrich = plot.enrich)
    }

    if(plot.type == "means"){
        imageWithText(mean.mat[gene.order,,drop=FALSE], show.text = show.text, split.at.vals = TRUE, col.scale = c("blue", "brown"),
            grad.dir = "ends", row.text.shift = 0.15, col.text.shift = 0.08, col.text.rotation = 0,
            col.text.adj = 0.5, main = plot.label)
    }

    if(plot.type == "boxes"){
        plot.grouped.boxes(lapply(gene.means, function(x) x[,gene.order,drop=FALSE]), 
            type = "matrix", legend.x = legend.x, legend.y = legend.y,
            group.cols = geno.cols, print.vals = NA, main = plot.label)
        plot.dim <- par("usr")
        segments(x0 = 0, x1 = plot.dim[2], y0 = 0)
    }

    if(return.full.result){
        invisible(full.result)
    }else{
        invisible(common.genes)
    }
}

expr_loadings <- function(term.name, gene.list, expr.mat, group.list,
    loading.type = c("mean.diff", "PC")){
    
    term.idx <- which(names(gene.list) == term.name)
    if(length(term.idx) == 0){stop("Can't find ", term.name)}
    term.genes <- gene.list[[term.idx]]
    common.genes <- intersect(term.genes, rownames(expr.mat))

    if(length(common.genes) == 0){
        plot.text(paste("Cannot find genes for ", term.name))
    }

    term.expr <- expr.mat[common.genes,]
    gene.names <- mouse.genes[match(common.genes, mouse.genes[,"ensembl_gene_id"]), "entrezgene_id"]
    rownames(term.expr) <- gene.names
    group.means <- lapply(group.list, function(x) rowMeans(term.expr[,x]))

    if(loading.type == "mean.diff"){
        mean.diff <- group.means[[2]] - group.means[[1]]
        #hist(mean.diff)
        return(mean.diff)
    }
    if(loading.type == "PC"){
        #gene.decomp <- plot.decomp(t(term.expr), label.points = TRUE)
        gene.decomp <- plot.decomp(term.expr, plot.results = FALSE)
        gene.v <- gene.decomp$u[,1]
        names(gene.v)  <- gene.names
        return(gene.v)  
    }
    
}
```

```{r plot_individ_intersection, eval = FALSE}

#term.name <- rownames(sub.vals)[pos.sig[1]]
#term.name <- "Longevity regulating pathway : Endolysosome"
#term.name <- "Alzheimer disease : Mitochondrial Metabolism"
#term.name <- "Rap1 signaling pathway : APP Metabolism"
#term.name <- "Glutathione metabolism : Proteostasis"
#term.name <- "Ribosome : Synapse"
#term.name <- "Ribosome : Immune Response"
#term.name <- "Long-term potentiation : Lipid Metabolism"
term.name <- "Nicotine addiction : APP Metabolism"
#term.name <- "Dopaminergic synapse : APP Metabolism"
#term.name <- "Inflammatory mediator regulation of TRP channels : Lipid Metabolism"

app.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == "App"), "ensembl_gene_id"]

order.type  <- c("PC", "means", "genotype", "top.rank")
x <- c(0.8, 0.8, 0.05, 0.8)
for(i in 1:length(order.type)){
    png(paste0("~/Desktop/", "ordered_by_", order.type[i], ".png"), width = 10, height = 6, units = "in", res = 300)
    par(bg = NA)
    int.genes <- plot_individual_genes(intersection.name = term.name, 
        plot.type = "individual", order.by = order.type[i], stat.x = 0.03, 
        stat.y = 0.8)

    int.genes <- plot_individual_genes(gene.list = c(int.genes, app.id), 
        plot.type = "individual", order.by = order.type[i], stat.x = 0.03, 
        stat.y = 0.8)    
    dev.off()
}
#enrich <- gost(int.genes, organism = "mmusculus")
#plot.enrichment(enrich, num.terms = 30)
#test.mat <- adj_expr[,int.genes]
#test.means <- rowMeans(test.mat)
#test.pc <- plot.decomp(test.mat)$u[,1]
#plot.with.model(test.means, test.pc)
```

```{r int_dir}
intersection.dir <- file.path(results.dir, "Intersection_Plots")
if(!file.exists(intersection.dir)){dir.create(intersection.dir)}
```

```{r plot_all_intersections, eval = FALSE}

#Paths with high values on PC1
pdf(file.path(intersection.dir, paste0("High_Paths_Individuals_", group.representation, ".pdf")), width = 10, height = 5)
for(i in 1:length(pos.sig)){
    plot_individual_genes(intersection.name = rownames(sub.vals)[pos.sig[i]], 
        plot.type = "individual")
}
dev.off()

#pdf(file.path(intersection.dir, paste0("High_Paths_Means_", group.representation, ".pdf")), width = 5, height = 7)
#for(i in 1:length(pos.sig)){
#    plot_individual_genes(intersection.name = rownames(sub.vals)[pos.sig[i]], plot.type = "means")
#}
#dev.off()

#pdf(file.path(intersection.dir, "High_Paths_Boxes.pdf"), width = 20, height = 5)
#for(i in 1:length(pos.sig)){
#    plot_individual_genes(intersection.nam = rownames(sub.vals)[pos.sig[i]], plot.type = "boxes")
#}
#dev.off()


#Paths with low values on PC1
pdf(file.path(intersection.dir, paste0("Low_Paths_Individuals_", group.representation, ".pdf")), width = 10, height = 5)
for(i in 1:length(neg.sig)){
    plot_individual_genes(intersection.nam = rownames(sub.vals)[neg.sig[i]], plot.type = "individual")
}
dev.off()


#pdf(file.path(intersection.dir, paste0("Low_Paths_Means_", group.representation, ".pdf")), width = 5, height = 9)
#    for(i in 1:length(neg.sig)){
#        plot_individual_genes(intersection.nam = rownames(sub.vals)[neg.sig[i]], plot.type = "means")
#    }
#dev.off()


#pdf(file.path(intersection.dir, "Low_Paths_Boxes.pdf"), width = 20, height = 5)
#for(i in 1:length(neg.sig)){
#    plot_individual_genes(intersection.nam = rownames(sub.vals)[neg.sig[i]], plot.type = "boxes")
#}
#dev.off()

```

```{r app_check, eval = FALSE}
#get all top paths that have a given term, and look at 
#expression of those genes

#this function looks at the top pathways (either positive or negative)
#It collect all the genes that fall under a single term across multiple
#interactions, for example, all KEGG-Biodomain interactions that involve
#Synapse. It plots the gene level statistics for all the genes, as well
#as the enrichment for those genes. This might help untangle synaptic 
#genes that are upregulated in VS vs. those that are downregulated, for
#example.

#Positive and negative are sort of arbitraty because they depend
#on the sign of the PC, but you can tell from the plots whether 
#VS is up or down

plot_merged_list <- function(search.term, path.type = c("Positive", "Negative")){

    if(path.type == "Positive"){
        app.idx <- grep(search.term, rownames(sub.vals)[pos.sig]); name.list <- rownames(sub.vals)[pos.sig]
    }else{
        app.idx <- grep(search.term, rownames(sub.vals)[neg.sig]); name.list <- rownames(sub.vals)[neg.sig]
    }

    if(length(app.idx) == 0){
        stop(paste("I couldn't find", search.term))
    }

    app.int <- name.list[app.idx]
    print(app.int)

    app.list <- lapply(app.int, function(x) plot_individual_genes(x, plot.type = "none"))
    app.genes <- Reduce("union", app.list)
    app.result <- plot_individual_genes(gene.list = app.genes, 
        plot.label = paste(search.term, "genes in", path.type, "Pathways"))

    app.enrich <- gost(app.genes, organism = "mmusculus", 
        sources = c("GO", "KEGG", "REACTOME", "CORUM", "HP"))

    #quartz()
    plot.enrichment(app.enrich, num.terms = 30, 
        plot.label = paste("Enrichment of", search.term, "genes in", path.type, "Pathways"))
}

plot_merged_list("Synapse", "Positive"); #cell adhesion
plot_merged_list("Synapse", "Negative"); #ribosome, translation at synapse


test.genes <- plot_individual_genes(intersection.nam = "Ras signaling pathway : APP Metabolism")
enrich <- gost(test.genes, organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME", "CORM", "HP"))

par(mar = c(4,20, 2,2))
plot.enrichment(enrich, num.terms = 30, max.char = 100)
#cat(test.genes, sep = "\n")
```

I think a lot of these terms have similar genes in them.
The code blow generates Jaccard index matrices and plots
them to the Intersection Plot folder. The names are too long
to plot in the html.

I talked to Greg about acknowledging the redundancy across edges.
He thinks it's not a big deal. Each pathway intersection gives us
different information. If genes participate in multiple pathways,
that pleiotropy should be acknowledged.


```{r, term_sim, eval = FALSE}
high.genes <- vector(mode = "list", length = length(pos.sig))
names(high.genes) <- rownames(sub.vals)[pos.sig]
for(i in 1:length(pos.sig)){
    high.genes[[i]] <- plot_individual_genes(intersection.name = rownames(sub.vals)[pos.sig[i]], plot.type = "none")
}

high.gene.jaccard <- jaccard.matrix(high.genes)

pdf(file.path(intersection.dir, paste0("High_Paths_Jaccard_", group.representation, ".pdf")), width = 30, height = 30)
pheatmap(high.gene.jaccard)
dev.off()


low.genes <- vector(mode = "list", length = length(neg.sig))
names(low.genes) <- rownames(sub.vals)[neg.sig]
for(i in 1:length(neg.sig)){
    low.genes[[i]] <- plot_individual_genes(intersection.nam = rownames(sub.vals)[neg.sig[i]], plot.type = "none")
}
low.gene.jaccard <- jaccard.matrix(low.genes)

pdf(file.path(intersection.dir, paste0("Low_Paths_Jaccard_", group.representation, ".pdf")), width = 20, height = 20)
pheatmap(low.gene.jaccard)
dev.off()
```

```{r weighted_degree, eval = FALSE}
#testing ideas for acknowledging redundancy across edges

test.net <- high.net
test.jacc <- high.gene.jaccard
test.deg <- degree(high.net)
diag(test.jacc) <- 0



pdf("~/Desktop/jaccard.pdf", width = 9, height = 20)
par(mar = c(4,30, 4, 2))
test.idx <- 3
barplot(sort(test.jacc[test.idx,]), horiz = TRUE, las = 2, main = rownames(test.jacc)[test.idx], xlim = c(0, max(test.jacc)))
dev.off()

scaled.deg <- degree(high.net)
for(i in 1:vcount(test.net)){
    #find all the edtes associated with each node
    if(test.deg[i] > 1){
        node.name <- V(test.net)$name[i]
        edge.idx <- grep(node.name, colnames(test.jacc))
        if(length(edge.idx) > 2){ #if there are at least 3 things to cluster
            sub.net <- test.jacc[edge.idx, edge.idx]
            diag(sub.net) <- 0
            #pheatmap(sub.net, show_rownames = FALSE, show_colnames = FALSE, main = node.name)
            test.cl <- test.pam.k(sub.net, 2:(nrow(sub.net)-1), plot.results = FALSE)
            #boxplot(test.cl[[1]])
            best.k <- names(which.max(sapply(test.cl[[1]], max)))
            scaled.deg[i] <- as.numeric(best.k)
        }
    }
}

plot(high.deg, scaled.deg)


pdf("~/Desktop/scaled_net.pdf", width = 20, height = 20)
plot(high.net, vertex.color = V(high.net)$vertex.color, 
    vertex.size = scale.between.vals(scaled.deg*3, 5, 20),
    layout = layout_nicely, main = "Positive Pathways", edge.width = high.r2*20,
    edge.color = ecol, vertex.label.cex = scale.between.vals(scaled.deg/2, 1, 3))
dev.off()

```

## Term Connections

In the networks, biodomains are linked through KEGG pathways.
The biodomains were designed to be as non-overlapping as possible.
However, we know that they are correlated both through gene expression
correlations and through interacting biology. The connections to KEGG 
pathways might give us a sense about how different aspects of Alzheimer's 
disease are related to each other. By identifying genes that are 
differentially expressed across the genotypes and link biodomains
together, we might be able to identify shared biology across the
domains and identify causal factors that affect multiple pieces
of the pie.

Below we investigate genes that link biodomains through KEGG
pathways.

```{r connectors, fig.width = 5, fig.height = 5}

#bd.names <- c("Synapse", "Apoptosis"); kegg.names <- c("Type II diabetes mellitus")
#bd.names <- c("Synapse", "Proteostasis"); kegg.names <- c("Ribosome")
#bd.names <- c("Metal Binding and Homeostasis", "Mitochondrial Metabolism"); kegg.names <- c("Oxidative phosphorylation")
bd.names <- c("APP Metabolism", "Synapse"); kegg.names = c("Nicotine addiction")

term.pairs <- bipartite_pairs(bd.names, kegg.names, "Biodomains", "KEGG")

pair.genes <- vector(mode = "list", length = nrow(term.pairs))
names(pair.genes) <- apply(term.pairs, 1, function(x) paste(x, collapse = " : "))
for(i in 1:nrow(term.pairs)){
    bd.idx <- which(names(kegg.bd.list) == term.pairs[i,"Biodomains"])
    k.idx <- which(names(kegg.bd.list[[bd.idx]]) == term.pairs[i,"KEGG"])
    pair.genes[[i]] <- kegg.bd.list[[bd.idx]][[k.idx]]
}

plotVenn(pair.genes)
```


```{r mousemine_go_net, fig.width = 20, fig.height = 20, eval = FALSE}
#attempts to make gene-term networks have largely failed
#to complex, no good way to filter to a reasonable number
#of terms

connector.genes <- Reduce("intersect", pair.genes)
#cat(connector.genes, sep = "\n")

#get gene-GO associations
enrich <- gost(connector.genes, organism = "mmusculus", evcodes = TRUE)
plot.enrichment(enrich, num.terms = 30)


#mousemine GO network
#put the connector genes into mouse mine, filter the GO term table
#to a few most relevant GO terms. These will be the ones at the top
#with a lot of genes associated. Download the filtered table
#plot the genes and GO terms as a network
#It will probably be messy, but it is a way to see
#which genes in a list are involved in relevant functions
#for example ribosomal genes that are at the synapse and involved
#in immune function.
mouse.table <- read.delim("~/Downloads/MFeature_GO.tsv", header = FALSE)

go.col <- 8
u_go <- unique(mouse.table[,go.col])
u_word <- unique(unlist(sapply(u_go, function(x) strsplit(x, " "))))
word_mat <- matrix(0, nrow = length(u_word), ncol = length(u_go))
rownames(word_mat) <- u_word
colnames(word_mat) <- u_go
for(i in 1:length(u_word)){
    go.pos <- grep(u_word[i], u_go)
    word_mat[i,go.pos] <- 1
}

word.decomp <- plot.decomp(t(word_mat))
word_cl <- pam(word.decomp$u, k = 5)
plot.decomp(t(word_mat), cols = word_cl$clustering)

#pdf("~/Desktop/go_net.pdf", width = 20, height = 20)
mousemine_network(mouse.table, gene.col = 2, min.cex = 2, min.v.size = 3, max.v.size = 10)
#dev.off()
```

The figure below shows the overall statistics for this
set of genes.

```{r connector_example, fig.width = 10, fig.height = 5}
connector.genes <- Reduce("intersect", pair.genes)

#png(file.path(results.dir, "connector.png"), width = 10, height = 6, units = "in", res = 300)
plot.label <- paste(c(bd.names, kegg.names), collapse = "_")
connector.result <- plot_individual_genes(gene.list = connector.genes, 
    plot.type = "individual", plot.label = plot.label, 
    label.margin = 4, order.by = "PC", return.full.result = TRUE)
#dev.off()
```

The enrichments of the intersectional genes are shown below.

```{r connector_enrichment, fig.widht = 7, fig.height = 7}
connector.enrich <- gost(connector.genes, organism = "mmusculus", 
    sources = c("GO", "KEGG", "REACTOME", "HP", "CORUM"))
plot.enrichment(connector.enrich, num.terms = 30, max.term.size = 3000)
#cat(connector.genes, sep = "\n")
```

The plots below show the distributions of the individual gene's
expression.

```{r individual_genes, fig.width = 9, fig.height = 9}
#plot_individual_genes(gene.list = connector.genes, plot.type = "boxes", plot.label = "", legend.x = 36, legend.y = 4)
#plot_individual_genes(gene.list = connector.genes, plot.type = "means", plot.label = "")
connector.names <- names(connector.result$row.r2)
connector.order <- order(connector.result$decomp$v[,1])

#pdf("~/Desktop/connector_levels.pdf", width = 9, height = 9)
layout(get.layout.mat(min(c(9, length(connector.names)))))
for(i in 1:length(connector.names)){
    gene_vioplot(gsub("*", "", connector.names[connector.order[i]], fixed = TRUE), autoflip.stat.y = TRUE)
}
#dev.off()
```


```{r pathview, eval = FALSE}
library(pathview)

kegg.file <- here("Data", "general", "KEGG.Mouse.RDS")
if(!file.exists(kegg.file)){
    all.kegg <- download_KEGG("mmu", "KEGG", "kegg")
    saveRDS(all.kegg, kegg.file)
}else{
    all.kegg <- readRDS(kegg.file)
}

u_path <- gsub(" - Mus musculus (house mouse)", "", all.kegg[[2]][,"to"], fixed = TRUE)

# build GSEA list
path.id <- all.kegg[[2]][,1]
path.idx <- lapply(path.id, function(x) which(all.kegg[[1]][,1] == unlist(x)[1]))
path.gene.id <- lapply(path.idx, function(x) all.kegg[[1]][x,2])
names(path.gene.id) <- u_path

path.gene.ensembl <- lapply(path.gene.id, 
    function(x) mouse.genes[match(x, mouse.genes[,"entrezgene_id"]), "ensembl_gene_id"])


comp_groups <- list("FC" = grep("FC", covar.table[,"climb_geno"]), "VS" = grep("VS", covar.table[,"climb_geno"]))

#int.name <- rownames(sub.vals)[pos.sig[1]]
#int.name <- "Longevity regulating pathway : Endolysosome"
#int.name <- "Alzheimer disease : Mitochondrial Metabolism"

kegg.name <- "Phagosome"
kegg.name <- "Cell adhesion molecules"
kegg.name <- "Longevity regulating pathway"
kegg.name <- "Ribosome"
kegg.name <- "Oxidative phosphorylation"
kegg.name <- "Proteasome"
kegg.name <- "Protein export"
kegg.name <- "ECM-receptor interaction"
kegg.name <- "Glutamatergic synapse"
kegg.name <- "Alzheimer disease"

#plot_individual_genes(gene.list = kegg.list$"Alzheimer disease")

#give each gene a "loading", which is a comparison of expression
#between the FC and VS groups
expr.vals <- expr_loadings(term.name = kegg.name, gene.list = kegg.list, 
    expr.mat = t(adj_expr), group.list = comp_groups, loading.type = "PC")
#hist(expr.vals)
scaled.vals <- scale.between.vals(expr.vals, -1, 1)
#hist(scaled.vals)
#plot(expr.vals, scaled.vals);abline(h = 0, v = 0)
path.num <- path.id[which(u_path == kegg.name)]
pv.out <- pathview(gene.data = scaled.vals, 
    pathway.id = path.num, species = "mmu", 
    out.suffix = kegg.name,
    kegg.dir = intersection.dir)
```

```{r kegg_diff, eval = FALSE}
for(k in 1:length(kegg.list)){
    kegg.vals <- expr_loadings(names(kegg.list)[i], kegg.list, t(adj_expr), comp_groups)   
    boxplot(kegg.vals)
}


all.kegg.diff <- lapply(names(kegg.list), function(x) expr_loadings(x, kegg.list, t(adj_expr), comp_groups))

diff.mean <- sapply(all.kegg.diff, mean)
boxplot(all.kegg.diff[order(diff.mean)])
abline(h = 0)

names(kegg.list)[head(order(diff.mean))]
names(kegg.list)[tail(order(diff.mean))]

common.kegg <- lapply(kegg.list, function(x) intersect(x, colnames(adj_expr)))
kegg.means <- sapply(common.kegg, function(x) rowMeans(adj_expr[,x]))
plot_mean_bd_k(t(kegg.means), covar.table)

kegg.decomp <- plot.decomp(t(kegg.means))
kegg.vals <- kegg.decomp$u[,1]
low.thresh <- get.percentile(kegg.vals, 1)
high.thresh <- get.percentile(kegg.vals, 99)

high.kegg <- which(kegg.vals >= high.thresh)
low.kegg <- which(kegg.vals <= low.thresh)

#names(kegg.list)[high.kegg]
#names(kegg.list)[low.kegg]
extreme.kegg <- names(kegg.list)[c(high.kegg, low.kegg)]
for(k in 1:length(extreme.kegg)){
    expr.vals <- expr_loadings(extreme.kegg[k], kegg.list, t(adj_expr), comp_groups)
    #print(length(expr.vals))
    if(length(expr.vals) > 10){
        #hist(expr.vals)
        scaled.vals <- scale.between.vals(expr.vals, -1, 1)
        #hist(scaled.vals)
        #plot(expr.vals, scaled.vals);abline(h = 0, v = 0)
        path.num <- path.id[which(u_path == extreme.kegg[k])]
        pv.out <- try(pathview(gene.data = scaled.vals, 
            pathway.id = path.num, species = "mmu", 
            out.suffix = extreme.kegg[k],
            kegg.dir = intersection.dir))
    }
}
```

```{r kegg_biodomain_illustration}

k_bd_illustration <- function(BD_label = "Apoptosis", KEGG_label = "MAPK\nsignaling"){
    par(mar = c(0,0,0,0))
    plot.new()
    plot.window(xlim = c(0, 1), ylim = c(0, 1))
    round_rect(0.05, 0.25, 0.5, 0.75, col = add_alpha("#90C786", alpha = 0.5))
    text(x = 0.28, y = 0.78, labels = "KEGG", adj = 0.5)
    text(x = 0.21, y = 0.5, labels = KEGG_label)
    go.circle <- get_circle(0.25, 0.6, 0.5)
    lower.idx <- which(go.circle$y <= 0.5)
    upper.idx <- which(go.circle$y >= 0.5)
    plot.poly.xy(go.circle$x[upper.idx], go.circle$y[upper.idx], 
    go.circle$x[lower.idx], go.circle$y[lower.idx], border = NA,
    col = add_alpha("#BBAFD1", alpha = 0.5))
    points(go.circle$x, go.circle$y, type = "l")
    text(x = 0.62, y = 0.78, labels = "Biodomain")
    text(x = 0.65, y = 0.5, labels = BD_label)
    arrows(x0 = 0.48, y0 = 0.35, y1 = 0.15, lwd = 3, length = 0.2)
}
```

```{r intersection_example_fig}
#here we plot violin plots of specific terms we are interested in.

pdf(here("Results", "for_paper", "Intersection_examples.pdf"), width = 5, height = 5)
term_vioplot(outer.term = "MAPK signaling pathway", inner.term = "Apoptosis", 
    mean.term.vals = mean.bd.k.vals, stat.x = 0.05, stat.y = 0.2, 
    stat.y.spread = 0.12, autoflip.stat.y = FALSE)

term_vioplot(outer.term = "MAPK signaling pathway", inner.term = "DNA Repair", 
    mean.term.vals = mean.bd.k.vals, stat.x = 0.05, stat.y = 0.95, 
    autoflip.stat.y = FALSE, stat.y.spread = 0.12)
dev.off()


pdf(here("Results", "for_paper", "Intersection_illustration.pdf"), width = 4, height = 4)
k_bd_illustration("Apoptosis", "MAPK\nsignaling")
k_bd_illustration("DNA Repair", "MAPK\nsignaling")
dev.off()

```

## Gene-gene correlations

Ultimately, we are interested in the interaction between
Apoe and Klotho in terms of AD susceptibility. We will 
test this explicitly later, but here we can get a sense
of how these genes are related in this system.

We are seeing a lot of lipid metabolism terms in these,
and it's possible that cholesterol is at the center of
all of this. 

APP regulates brain APOE and cholesterol metabolism through
the lipoprotein receptor LRP1 (Liu et al. 2007, Neuron, 
pmid: 17920016). Overexpression of LDLR inhibits amyloid
deposition and increases extracellular A-beta clearance
(Kim et al. 2009, Neuron, pmid: 20005821). 

Cholesterol is also used to make vitamin D, which is 
also Klotho related. Klotho forms a complex with FGF23
to suppress conversion of inactive vitamin D to its 
active form. Vitamin D increases Klotho expression 
(more details in pmid: 38213484).

What are the correlations among expression of these genes 
in these mice?

The heatmap below shows a strong negative correlation between
Apoe expression and that of Lrp1 and App, and a weaker negative
correlation between Apoe and Ldlr. Apoe, Lrp1, and Ldlr are
positively correlated with each other. Klotho and Fgf23 are 
not really correlated with anything.

```{r correlation_fun}
test_corr_int <- function(gene.id){
    #which genes do we have expression for?
    common.genes <- intersect(gene.id, colnames(adj_expr))
    #get their names
    common.names <- mouse.genes[match(common.genes, mouse.genes[,"ensembl_gene_id"]), "external_gene_name"]
    #get their expression
    expr.mat <- adj_expr[,common.genes]
    colnames(expr.mat) <- common.names

    gene.pairs <- pair.matrix(common.names, ordered = TRUE)

    pair.int.p <- pair.int.effect <- matrix(NA, nrow = length(common.names), 
        ncol = length(common.names))
    rownames(pair.int.p) <- colnames(pair.int.p) <- 
        rownames(pair.int.effect) <- colnames(pair.int.effect) <- common.names

    carrier.geno <- c("FC", "VS")
    carrier.idx <- lapply(carrier.geno, function(x) grep(x, test.factor))
    names(carrier.idx) <- carrier.geno

    for(i in 1:nrow(gene.pairs)){
        #report.progress(i, nrow(gene.pairs))
        gene1 <- gene.pairs[i,1]
        gene2 <- gene.pairs[i,2]
        
        data1 <- expr.mat[,gene1]
        data2 <- expr.mat[,gene2]

        #explain expression in the second gene using the first gene 
        #gene1 -> gene2
        model <- lm(data2~data1*test.factor)

        #set the row index of the linear coefficient for the interaction term
        int.idx <- which(rownames(coef(summary(model))) == "data1:test.factor.L")
        lin.coef <- coef(summary(model))[int.idx,"Estimate"]
        lin.p <- coef(summary(model))[int.idx,"Pr(>|t|)"]
        pair.int.effect[gene1, gene2] <- lin.coef #row gene -> columnn gene
        pair.int.p[gene1, gene2] <- lin.p ##row gene -> columnn gene
    }

    result <- list("Estimate" = pair.int.effect, "p" = pair.int.p)
    return(result)
}

one_chunk_pairs <- function(all.expr, chunk.pairs, int.factor){
    result.coef <- result.p <- matrix(0, nrow = ncol(all.expr), ncol = ncol(all.expr))
    colnames(result.coef) <- rownames(result.coef) <- colnames(result.p) <- rownames(result.p) <- colnames(all.expr)
    for(i in 1:nrow(chunk.pairs)){
        gene1 <- chunk.pairs[i,1]
        gene2 <- chunk.pairs[i,2]
        model1 <- lm(all.expr[,gene1]~all.expr[,gene2]*int.factor)
        model2 <- lm(all.expr[,gene2]~all.expr[,gene1]*int.factor)

        int.idx <- which(rownames(coef(summary(model1))) == "all.expr[, gene2]:int.factor.L")
        result.coef[gene2, gene1] <- coef(summary(model1))[int.idx,"Estimate"]
        result.coef[gene1, gene2] <- coef(summary(model2))[int.idx,"Estimate"]
        result.p[gene2, gene1] <- coef(summary(model1))[int.idx,"Pr(>|t|)"]
        result.p[gene1, gene2] <- coef(summary(model2))[int.idx,"Pr(>|t|)"]
    }
    return(list("coef" = result.coef, "p" = result.p))
}

#how do we parallelize testing all directed pairs?
#break the pair list into ncores chunks, send the
#required expression matrix and the list of pairs
#to the node, and just perform those tests.
test_corr_int_parallel <- function(expr.mat, int.factor, ncores = 4){

    gene.pairs <- pair.matrix(colnames(expr.mat))

    if(nrow(gene.pairs) > ncores){
        chunked_pairs <- lapply(chunkV(1:nrow(gene.pairs), ncores), function(x) gene.pairs[x,])
    }else{
        chunked_pairs <- lapply(list(1:nrow(gene.pairs)), function(x) gene.pairs[x,])
    }

    #break up the expression matrix into just the chunks that will go to each node
    chunked.genes <- lapply(chunked_pairs, function(x) unique(as.vector(x)))

    cl <- makeCluster(ncores)
    registerDoParallel(cl)
    pair_results_list <- foreach(m = 1:length(chunked_pairs), .export = c("one_chunk_pairs")) %dopar% {
      one_chunk_pairs(expr.mat, chunk.pairs = chunked_pairs[[m]], int.factor)
    }
    stopCluster(cl)

    #put everything back together
    pair.int.coef <- Reduce("+", lapply(pair_results_list, function(x) x[[1]]))
    pair.int.p <- Reduce("+", lapply(pair_results_list, function(x) x[[2]]))
    
    #convert diagonal to NA
    diag(pair.int.coef) <- NA
    diag(pair.int.p) <- NA

    result <- list("Estimate" = pair.int.coef, "p" = pair.int.p)
    return(result)
}

#builds a network out of the results from test_corr_int
corr_net <- function(int_result, p.thresh = 0.001, plot.results = FALSE,
    plot.label = "", layout.mat = NULL){

    gene.names <- colnames(int_result[[1]])
    sig.effects <- which(int_result[[2]] <= p.thresh, arr.ind = TRUE)
    edge.list <- cbind(gene.names[sig.effects[,1]], gene.names[sig.effects[,2]])
    cor_net <- graph_from_edgelist(edge.list)
    sig.effect.size <- int_result[[1]][sig.effects]
    sig.effect.p <- int_result[[2]][sig.effects]
    E(cor_net)$weight <- sig.effect.size

    if(plot.results){
        edge.col <- colors.from.values(sig.effect.size, split.at.vals = TRUE,
            col.scale = c("blue", "brown"), grad.dir = "ends")
        par(mar = c(0,0,2,0))
        if(is.null(layout.mat)){
            pos.edge <- cor_net
            E(pos.edge)$weight <- abs(E(cor_net)$weight)
            layout.mat <- layout_nicely(pos.edge)
        }
        plot(cor_net, vertex.size = 0.1, edge.color = edge.col, edge.arrow.size = 0.7,
            edge.width = abs(sig.effect.size)*3, layout = layout.mat, main = plot.label)
    }
    return(cor_net)
}

#this function calculates gene-gene correlations for all significant
#edges in the interaction test. The correlations are calculated
#separately for individuals carrying FC alleles and VS alleles.
#these networks should have the same number of vertices as the
#directed networks, but will likely have fewer edges, because they
#are undirected.
net_by_geno <- function(int_result, p.thresh = 0.001, plot.result = FALSE, 
    layout.mat = NULL, vertex.size = 0.5, edge.arrow.size = 0.7, 
    edge.width.factor = 5, title.level = "####", highlight.nodes = NULL, 
    highlight.width = 0.08, highlight.height = 0.05, 
    highlight.cex = 1, highlight.lwd = 2, highlight.font = 2){

    gene.names <- colnames(int_result[[1]])
    sig.effect <- which(int_result[[2]] <= p.thresh, arr.ind = TRUE)
    sig.genes <- cbind(gene.names[sig.effect[,1]], gene.names[sig.effect[,2]])
    u_sig <- unique(as.vector(sig.genes))
    sig_id <- cbind(mouse.genes[match(sig.genes[,1], mouse.genes[,"external_gene_name"]),"ensembl_gene_id"],
                    mouse.genes[match(sig.genes[,2], mouse.genes[,"external_gene_name"]),"ensembl_gene_id"])

    fc.cor <- vs.cor <- matrix(0, nrow = length(u_sig), ncol = length(u_sig))
    rownames(fc.cor) <- colnames(fc.cor) <- rownames(vs.cor) <- colnames(vs.cor) <- u_sig

    fc.idx <- grep("FC", test.factor)
    vs.idx <- grep("VS", test.factor)
    for(i in 1:nrow(sig.genes)){
        name1 <- sig.genes[i,1]; id1 <- sig_id[i,1]
        name2 <- sig.genes[i,2]; id2 <- sig_id[i,2]
        fc.cor[name1, name2] <- cor(adj_expr[fc.idx,id1], adj_expr[fc.idx,id2])
        fc.cor[name2, name1] <- cor(adj_expr[fc.idx,id1], adj_expr[fc.idx,id2])
        vs.cor[name1, name2] <- cor(adj_expr[vs.idx,id1], adj_expr[vs.idx,id2])
        vs.cor[name2, name1] <- cor(adj_expr[vs.idx,id1], adj_expr[vs.idx,id2])
    }

    #plot(fc.cor, vs.cor); abline(v = 0, h = 0)
    fc.net <- graph_from_adjacency_matrix(fc.cor, weighted = TRUE, mode = "undirected")
    vs.net <- graph_from_adjacency_matrix(vs.cor, weighted = TRUE, mode = "undirected")
    #plot(E(fc.net)$weight, E(vs.net)$weight); abline(v = 0, h = 0)

    if(plot.result){

        global.min <- min(c(E(fc.net)$weight, E(vs.net)$weight))
        global.max <- max(c(E(fc.net)$weight, E(vs.net)$weight))
        
        cat(title.level, "FC\n")
        plot_net(fc.net, layout.mat = layout.mat, global.min = global.min, 
            global.max = global.max, vertex.size = vertex.size, 
            plot.label = "FC", edge.arrow.size = edge.arrow.size, 
            edge.width.factor = edge.width.factor, highlight.nodes = 
            highlight.nodes, highlight.width = highlight.width, 
            highlight.height = highlight.height, 
            highlight.cex = highlight.cex, highlight.lwd = highlight.lwd, 
            highlight.font = highlight.font)
        cat("\n\n")

        cat(title.level, "VS\n")
        plot_net(vs.net, layout.mat = layout.mat, global.min = global.min, 
            global.max = global.max, vertex.size = vertex.size, 
            plot.label = "VS", edge.arrow.size = edge.arrow.size, 
            edge.width.factor = edge.width.factor, highlight.nodes = 
            highlight.nodes, highlight.width = highlight.width, 
            highlight.height = highlight.height, 
            highlight.cex = highlight.cex, highlight.lwd = highlight.lwd, 
            highlight.font = highlight.font)
        cat("\n\n")
    }

    result <- list("FC_net" = fc.net, "VS_net" = vs.net)
    return(result)
}

get_layout <- function(net){
    pos.net <- net
    E(pos.net)$weight <- abs(E(net)$weight)
    layout.mat <- layout_nicely(pos.net)
    rownames(layout.mat) <- V(net)$name
    return(layout.mat)
}

plot_net <- function(net, layout.mat = NULL, global.min = NULL, global.max = NULL,
    vertex.size = 0.5, plot.label = "", edge.arrow.size = 0.7, edge.width.factor = 5,
    highlight.nodes = NULL, highlight.width = 0.08, highlight.height = 0.05, 
    highlight.cex = 1, highlight.lwd = 2, highlight.font = 2){

    if(!is.null(layout.mat)){
        layout.names <- rownames(layout.mat)
        if(is.null(layout.names)){stop("The layout matrix must have row names.")}
    }

    if(is.null(layout.mat)){
        layout.mat <- get_layout(net)
    }

    plot.net.name <- V(net)$name
    plot.net.order <- match(plot.net.name, rownames(layout.mat))
    plot.layout <- layout.mat[plot.net.order,]

    if(is.null(global.min)){
        global.min <- min(E(net)$weight)
    }
    if(is.null(global.max)){
        global.max <- max(E(net)$weight)
    }

    edge.col <- colors.from.values(E(net)$weight, split.at.vals = TRUE,
        col.scale = c("blue", "brown"), grad.dir = "ends", light.dark = "f", 
        global.color.scale = TRUE, global.min = global.min, global.max = global.max)

    if(!is.null(V(net)$weight)){
        node.col <- colors.from.values(V(net)$weight, split.at.vals = TRUE,
        col.scale = c("blue", "brown"), grad.dir = "ends", light.dark = "f", 
        global.color.scale = TRUE, global.min = global.min, global.max = global.max)
    }else{
        node.col = "lightblue"
    }

    par(mar = c(0,0,4,0))
    plot(net, edge.color = edge.col, vertex.color = node.col,
        vertex.size = vertex.size, layout = plot.layout, main = plot.label, 
        edge.width = abs(E(net)$weight)*edge.width.factor, 
        edge.arrow.size = edge.arrow.size)

    if(!is.null(highlight.nodes)){
        scaled.coord <- apply(plot.layout, 2, function(x) scale.between.vals(x, -1, 1))
        for(i in 1:length(highlight.nodes)){
            node.idx <- which(rownames(scaled.coord) == highlight.nodes[i])
            node.coord <- scaled.coord[node.idx,]
            draw.rectangle(node.coord[1]-highlight.width, node.coord[1]+highlight.width, 
                node.coord[2]-highlight.height, node.coord[2]+highlight.height, fill = "white",
                border = "black", lwd = highlight.lwd)
            text(node.coord[1], node.coord[2], highlight.nodes[i], cex = highlight.cex, 
                font = highlight.font)
        }
    }
}

direct_connect <- function(net, gene.name, mode = c("all", "out", "in","total")){
    mode = mode[1]
    gene.idx <- which(V(net)$name == gene.name)
    next_door <- neighbors(net, gene.idx, mode = mode)
    return(next_door)
}

plot_one_interaction <- function(gene1, gene2, plot.results = TRUE, report = "cor.test"){
    ind.col <- sapply(test.factor, function(x) geno.cols[which(names(geno.cols) == x)])
    g1.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene1), "ensembl_gene_id"]
    if(length(g1.id) == 0){stop(paste("I couldn't find", gene1))}
    g2.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene2), "ensembl_gene_id"]
    if(length(g2.id) == 0){stop(paste("I couldn't find", gene2))}

    if(plot.results){
        layout.mat <- get.layout.mat((length(geno.idx)+2))
        #layout.mat[which(layout.mat == 0)] <- (length(geno.idx)+2)
        layout(layout.mat)
    }
    stats <- plot.with.model(adj_expr[, g2.id], adj_expr[, g1.id], 
        col = ind.col, xlab = gene2, ylab = gene1, main = "All",
        report = "cor.test", plot.results = plot.results)
    plot.dim <- par("usr")

    int.stats <- matrix(NA, nrow = (length(geno.idx)+1), ncol = 2)
    colnames(int.stats) <- names(stats)
    rownames(int.stats) <- c("all", names(geno.idx))    
    int.stats[1,] <- stats
    for(g in 1:length(geno.idx)){
        ind.idx <- geno.idx[[g]]
        int.stats[(g+1),] <- plot.with.model(adj_expr[ind.idx, g2.id], adj_expr[ind.idx, g1.id], 
            col = geno.cols[names(geno.idx)[g]], xlab = gene2, ylab = gene1, xlim = plot.dim[1:2],
            ylim = plot.dim[3:4],
            main = names(geno.idx)[g], report = report, plot.results = plot.results)
    }
    if(plot.results){
        barplot(int.stats[,1], col = c("gray90", geno.cols), ylab = "Correlation (r)",
            main = paste0(gene2, "-", gene1, " correlations"))
        abline(h = 0)
    }
    return(int.stats)
}

plot_directionality <- function(gene1, gene2, plot.results = TRUE, report = "cor.test"){
    
    ind.col <- sapply(test.factor, function(x) geno.cols[which(names(geno.cols) == x)])
    g1.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene1), "ensembl_gene_id"]
    if(length(g1.id) == 0){stop(paste("I couldn't find", gene1))}
    g2.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene2), "ensembl_gene_id"]
    if(length(g2.id) == 0){stop(paste("I couldn't find", gene2))}

    forward.int <- lm(adj_expr[,g2.id]~adj_expr[,g1.id]*test.factor)
    forward.main <- lm(adj_expr[,g2.id]~adj_expr[,g1.id])
    forward.pred.int <- predict(forward.int)
    forward.pred.main <- predict(forward.main)
    forward.comp <- anova(forward.int, forward.main)

    reverse.int <- lm(adj_expr[,g1.id]~adj_expr[,g2.id]*test.factor)
    reverse.main <- lm(adj_expr[,g1.id]~adj_expr[,g2.id])
    reverse.pred.int <- predict(reverse.int)
    reverse.pred.main <- predict(reverse.main)
    reverse.comp <- anova(reverse.int, reverse.main)

    compare.forward <- anova(forward.main, forward.int)
    compare.reverse <- anova(reverse.main, reverse.int)

    forward.rss <- compare.forward[,"RSS"]
    forward.p <- compare.forward[,"Pr(>F)"][2]
    reverse.rss <- compare.reverse[,"RSS"]
    reverse.p <- compare.reverse[,"Pr(>F)"][2]

    if(plot.results){
        #par(mfrow = c(2,2))
        #plot.with.model(adj_expr[,g2.id], g2.pred.main, col = ind.col, ylab = paste(gene2, "predicted"), xlab = gene2, main = paste(gene1, "->", gene2))
        #plot.with.model(adj_expr[,g1.id], g1.pred.main, col = ind.col, ylab = paste(gene1, "predicted"), xlab = gene1, main = paste(gene2, "->", gene1))

        layout.matrix <- matrix(c(1,2,0,3,4,5), nrow = 2, byrow = TRUE)
        layout(layout.matrix)

        plot.with.model(adj_expr[,g2.id], forward.pred.int, col = ind.col, ylab = paste(gene2, "predicted"), 
            xlab = gene2, main = paste(gene1, "->", gene2))
        plot.with.model(adj_expr[,g1.id], reverse.pred.int, col = ind.col, ylab = paste(gene1, "predicted"), 
            xlab = gene1, main = paste(gene2, "->", gene1))

        ymax <- max(c(forward.rss, reverse.rss))
        barplot(forward.rss, ylim = c(0, ymax), names = c("no interaction", "interaction"), main = paste(gene1, "->", gene2), ylab = "RSS")
        barplot(reverse.rss, ylim = c(0, ymax), names = c("no interaction", "interaction"), main = paste(gene2, "->", gene1), ylab = "RSS")
        barplot(-log10(c(forward.p, reverse.p)), names = c(paste0(gene1, "->", gene2), paste0(gene2, "->", gene1)), ylab = "-log10(p)")
    }
}


directed_residuals <- function(gene1, gene2, plot.results = TRUE, report = "cor.test", 
    cex.lab = 1, stat.x = 0.1, stat.y = 0.9, plot.predictions = FALSE, 
    plot.geno.effect = FALSE){

    ind.col <- sapply(test.factor, function(x) geno.cols[which(names(geno.cols) == x)])
    g1.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene1), "ensembl_gene_id"]
    if(length(g1.id) == 0){stop(paste("I couldn't find", gene1))}
    g2.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene2), "ensembl_gene_id"]
    if(length(g2.id) == 0){stop(paste("I couldn't find", gene2))}

    #fit additive models explaining each gene's expression with
    #the other gene's expression and genotype
    #get the residuals from the model
    add.forward <- lm(adj_expr[,g2.id]~adj_expr[,g1.id]+test.factor)
    add.reverse <- lm(adj_expr[,g1.id]~adj_expr[,g2.id]+test.factor)
    resid.forward <- resid(add.forward)
    resid.reverse <- resid(add.reverse)

    #fit the interaction models
    int.forward <- lm(adj_expr[,g2.id]~adj_expr[,g1.id]*test.factor)
    int.reverse <- lm(adj_expr[,g1.id]~adj_expr[,g2.id]*test.factor)

    if(plot.predictions){
        min.forward <- lm(adj_expr[,g2.id]~adj_expr[,g1.id])
        min.reverse <- lm(adj_expr[,g1.id]~adj_expr[,g2.id])

        pred.forward.min <- predict(min.forward) #predict gene2 expression using just gene1
        pred.reverse.min <- predict(min.reverse) #predict gene1 expression using just gene2
        pred.forward.add <- predict(add.forward) #predict gene2 expression using gene1 and genotype as an additive variable
        pred.reverse.add <- predict(add.reverse) #predict gene1 expression using gene2 and genotype as an additive variable
        pred.forward.int <- predict(int.forward) #predict gene2 expression using gene1 and genotype as an interactive variable
        pred.reverse.int <- predict(int.reverse) #predict gene1 expression using gene2 and genotype as an interactive variable

        #quartz(width = 5, height = 7.5)
        par(mfrow = c(3,2))
        plot.with.model(adj_expr[,g2.id], pred.forward.min, main = "forward no genotype", col = ind.col,
            xlab = gene1, ylab = paste("predicted", gene2), cex.lab = cex.lab)
        plot.with.model(adj_expr[,g1.id], pred.reverse.min, main = "reverse no genotype", col = ind.col,
            xlab = gene2, ylab = paste("predicted", gene1), cex.lab = cex.lab)
        plot.with.model(adj_expr[,g2.id], pred.forward.add, main = "forward additive", col = ind.col,
            xlab = gene1, ylab = paste("predicted", gene2), cex.lab = cex.lab)
        plot.with.model(adj_expr[,g1.id], pred.reverse.add, main = "reverse additive", col = ind.col,
            xlab = gene2, ylab = paste("predicted", gene1), cex.lab = cex.lab)
        plot.with.model(adj_expr[,g2.id], pred.forward.int, main = "forward interactive", col = ind.col,
            xlab = gene1, ylab = paste("predicted", gene2), cex.lab = cex.lab)
        plot.with.model(adj_expr[,g1.id], pred.reverse.int, main = "reverse interactive", col = ind.col,
            xlab = gene2, ylab = paste("predicted", gene1), cex.lab = cex.lab)
    }

    #plot the effect of genotype on gene1/2 when the other gene is high/low
    if(plot.geno.effect){
    
        #try looking at boxplots of gene expression of gene2 at high and 
        #low levels of gene1
        layout.mat <- matrix(c(5,5,1,2,6,6,3,4), ncol = 2, byrow = TRUE)
        layout(layout.mat, heights = c(0.2, 1, 0.2, 1))

        #forward direction
        par(mar = c(4,4,4,2), xpd = NA)

        #forward direction: gene2 is the response variable
        split.idx <- list("low" = which(adj_expr[,g1.id] < mean(adj_expr[,g1.id])),
            "high" = which(adj_expr[,g1.id] > mean(adj_expr[,g1.id])))
        test_effect(adj_expr[split.idx$low,g2.id], test.factor[split.idx$low],
            plot.results = TRUE, stat.x = stat.x, stat.y = stat.y, 
            stat.y.spread = stat.y.spread, plot.label = paste("Low expression of", gene1),
            cex.lab = cex.lab, ylab = gene2)

        test_effect(adj_expr[split.idx$high,g2.id], test.factor[split.idx$high],
            plot.results = TRUE, stat.x = stat.x, stat.y = stat.y, 
            stat.y.spread = stat.y.spread, plot.label = paste("High expression of", gene1),
            cex.lab = cex.lab, ylab = gene2)


        #reverse direction: gene1 is the response variable
        split.idx <- list("low" = which(adj_expr[,g2.id] < mean(adj_expr[,g2.id])),
            "high" = which(adj_expr[,g2.id] > mean(adj_expr[,g2.id])))
        test_effect(adj_expr[split.idx$low,g1.id], test.factor[split.idx$low],
            plot.results = TRUE, stat.x = stat.x, stat.y = stat.y, 
            stat.y.spread = stat.y.spread, plot.label = paste("Low expression of", gene2),
            cex.lab = cex.lab, ylab = gene1)

        test_effect(adj_expr[split.idx$high,g1.id], test.factor[split.idx$high],
            plot.results = TRUE, stat.x = stat.x, stat.y = stat.y, 
            stat.y.spread = stat.y.spread, plot.label = paste("High expression of", gene2),
            cex.lab = cex.lab, ylab = gene1)

        #add labels
        par(mar = c(0,0,0,0))
        plot.text(paste(gene1, "->", gene2), cex = 2, font = 2)
        plot.text(paste(gene2, "->", gene1), cex = 2, font = 2)
    }


    #get the p values for the interaction terms
    int.idx <- which(rownames(coef(summary(int.forward))) == "adj_expr[, g1.id]:test.factor.L")
    forward.int.p <- threshold_p(coef(summary(int.forward))[int.idx,"Pr(>|t|)"])
    reverse.int.p <- threshold_p(coef(summary(int.reverse))[int.idx,"Pr(>|t|)"])

    if(plot.results){
        
        #layout.mat <- get.layout.mat((length(geno.idx)*2))
        layout.mat <- matrix(1:((length(geno.idx)+1)*2), nrow = 2, byrow = TRUE)
        #add a plot at end of each row for the correlations and the p values
        layout.mat <- cbind(layout.mat, c((max(layout.mat)+1):(max(layout.mat)+2)))
        #add a row for the forward label
        layout.mat <- rbind(rep((max(layout.mat)+1), ncol(layout.mat)), layout.mat)
        #add a row for the reverse label, with a pane for a legend
        reverse.label <- rep((max(layout.mat)+1), ncol(layout.mat))
        reverse.label[length(reverse.label)] <- (reverse.label[1]+1)
        layout.mat <- rbind(layout.mat[1:2,], reverse.label, layout.mat[3,])
        layout(layout.mat, widths = c(rep(0.8, 4), 1), heights = c(0.2, 1, 0.2, 1))
        #layout.show(max(layout.mat))

        #forward direction
        forward.stats <- reverse.stats <- matrix(NA, ncol = 2, nrow = length(geno.idx))
        rownames(forward.stats) <- rownames(reverse.stats) <- names(geno.idx)
        colnames(forward.stats) <- colnames(reverse.stats) <- c("r", "p")

        #remove the effect of genotype
        dummy.factor <- dummy_covar(as.matrix(test.factor, ncol = 1))
        adj1 <- adjust(adj_expr[,g1.id,drop=FALSE], dummy.factor)
        adj2 <- adjust(adj_expr[,g2.id,drop=FALSE], dummy.factor)
        
        plot.with.model(adj1, adj2, col = ind.col,
            xlab = gene1, ylab = gene2, 
            main = "overall", report = "cor.test", cex.lab = cex.lab)

        for(g in 1:length(geno.idx)){
            ind.idx <- geno.idx[[g]]
            forward.stats[g,] <- plot.with.model(adj_expr[ind.idx,g1.id], resid.forward[ind.idx], 
                col = geno.cols[g], xlab = gene1, ylab = paste(gene2, "residuals"), 
                main = names(geno.cols)[g], report = "cor.test", cex.lab = cex.lab)
        }
        
        plot.with.model(adj2, adj1, col = ind.col,
            xlab = gene2, ylab = gene1, 
            main = "all", report = "cor.test", cex.lab = cex.lab)
        
        #reverse direction
        for(g in 1:length(geno.idx)){
            ind.idx <- geno.idx[[g]]
            reverse.stats[g,] <- plot.with.model(adj_expr[ind.idx,g2.id], resid.reverse[ind.idx], 
                col = geno.cols[g], xlab = gene2, ylab = paste(gene1, "residuals"), 
                main = names(geno.cols)[g], report = "cor.test", cex.lab = cex.lab)
        }
        
        #compare the correlation coefficients
        barplot(rbind(forward.stats[,1], reverse.stats[,1]), beside = TRUE, 
            col = rbind(geno.cols, geno.cols), density = c(NA, 50), 
            ylab = "Correlation Coefficient", main = "Correlations",
            cex.names = cex.lab, cex.lab = cex.lab)
        abline(h = 0)

        #compare the p values
        barplot(-log10(rbind(forward.stats[,2], reverse.stats[,2])), beside = TRUE, 
            col = rbind(geno.cols, geno.cols), density = c(NA, 50), 
            ylab = "-log10(p)", main = "-log10(p)", cex.names = cex.lab,
            cex.lab = cex.lab)
        plot.dim <- par("usr")
        abline(h = 0) 

        #add labels for forward and reverse:
        par(mar = c(0,4,0,4))
        plot.text(paste("Forward Direction:", gene1, "->", gene2, "\np =", forward.int.p), cex = 2, font = 2)
        plot.text(paste("Reverse Direction:", gene1, "<-", gene2, "\np =", reverse.int.p), cex = 2, font = 2, x = 0.75)

        #add a legend for the two bar plots
        plot.new()
        plot.window(xlim = c(0, 1), ylim = c(0, 1))
        legend(x = 0.2, y = 1, legend = names(geno.cols), fill = geno.cols)
        legend(x = 0.6, y = 1, legend = c("forward", "reverse"), 
            fill = c("white", "darkgray"), density = c(0, 50))
        
        result <- list("forward.stats" = forward.stats, "reverse.stats" = reverse.stats)
        invisible(result)
    }
}

```

To test whether Klotho genotype has an effect on these correlations,
we can check for interactions between Klotho genotype and the 
gene-gene relationships.

We ran a linear model using each gene in turn as the explanatory
and response variable and added genotype as an interaction term.
The volcano plot below shows the relationship between the effect
size of the interaction term and the -log10(p value). We picked
interaction terms above -log10(p) = 2, shown by the horizontal 
line.

```{r apoe_app}
#term.name <- "APP Metabolism"
#term.name <- "Oxidative Stress"
#term.idx <- which(names(bd.list) == term.name)
#test.id <- bd.list[[term.idx]]
term.name <- "all_genes" #this takes over 1 day and 12 hours on the cluster with 20 cores and 40 gigs of memory
test.id <- unique(unlist(kegg.bd.list)) #test everything in our intersection list
#length(test.id)

#start.lin <- Sys.time()
#corr_result1 <- test_corr_int(test.id)
#end.lin <- Sys.time()
#time.lin <- end.lin - start.lin
#print(time.lin)

corr_result_file <- file.path(results.dir, "gene_gene_correlations.RDS")
if(!file.exists(corr_result_file)){
    #start.par <- Sys.time()
    #pull out the expression of the genes we want to test
    common.id <- intersect(test.id, colnames(adj_expr)) #we can only test what we have expression data for
    sub.expr <- adj_expr[,common.id]
    #and give the genes human-readable names
    common.names <- mouse.genes[match(common.id, mouse.genes[,"ensembl_gene_id"]), "external_gene_name"]
    colnames(sub.expr) <- common.names
    corr_result <- test_corr_int_parallel(sub.expr, test.factor, ncores = 7)
    #end.par <- Sys.time()
    #time.par <- end.par - start.par
    #print(time.par)
    saveRDS(corr_result, corr_result_file)
}else{
    corr_result <- readRDS(corr_result_file)
}

pair.int.effect <- corr_result[[1]]
pair.int.p <- corr_result[[2]]
```

### Gene-gene interaction significance

The plot below shows the qq plot for the interaction p values.
The horizontal line marks where we have drawn our significance
threshold.

```{r qq}
net.thresh = 10^(-6)
qqunif.plot(as.vector(pair.int.p))
abline(h = -log10(net.thresh))
```

The following volcano plot shows the effect sizes of the 
interaction term compared with the -log10(p) of the interaction
term. The horizontal line shows the threshold above which we 
are considering the interactions significant.

I've turned off plotting, because the data are huge

```{r kl_int, eval = FALSE}
plot(pair.int.effect, -log10(pair.int.p), xlab = "Effect Size", ylab = "-log10(p)")
abline(h = -log10(net.thresh))
``

```{r get_sig}
sig.effect <- which(pair.int.p <= net.thresh, arr.ind = TRUE); #significant
#sig.effect <- which(-log10(pair.int.p) < 1e-3, arr.ind = TRUE); #not significant
#sig.genes <- cbind(colnames(pair.int.p)[sig.effect[,1]], colnames(pair.int.p)[sig.effect[,2]])
#i = i + 1;test <- plot_one_interaction(sig.genes[i,1], sig.genes[i,2])
#plot_one_mediation(sig.genes[i,1], sig.genes[i,2])
total.pairs <- length(pair.int.p)-ncol(pair.int.p)
frac.sig <- nrow(sig.effect)/total.pairs
```

We tested `r total.pairs` total correlations among `r ncol(pair.int.p)`
genes. At p value of `r net.thresh`, there were 
`r nrow(sig.effect)` correlations that depended significantly on 
genotype (`r signif(frac.sig*100, 2)`%).

### A directed network

The interaction network is directed because the interaction term
when one gene is the explanatory variable is differet from when 
the other gene is the explanatory variable. Below we plot the 
directed network for the APP Metabolism biodomain. The blue 
edges denote negative interactions and the brown arrows denote 
positive interactions. 

```{r dir_net, fig.width = 10, fig.height = 10}
#get a layout for all networks
dir.net <- corr_net(int_result = corr_result, p.thresh = net.thresh, plot.result = FALSE)
net.layout <- get_layout(dir.net)

#pdf("~/Desktop/dir.net.pdf", width = 10, height = 10)
plot_net(dir.net, layout.mat = net.layout,
    vertex.size = 1, plot.label = term.name)
#dev.off()
```

To better illustrate why the edges are directed, we can look
at one in more detail. Below we see that Mmp2 and Usp8 have
a directed interaction. Mmp2 expression explains Usp8 expression
differentially across the genotypes (top row). However, Usp8 
expression cannot be used to explain Mmp2 expression in any 
genotype (bottom row). The top bar plot compares the correlation
coefficients across the genotypes for the forward and reverse
interaction. An increase in Mmp2 is associated with a decrease
in Usp8 in the FC animals, but an increase in Usp8 in the VS
animals. However an increase in Usp8 is not associated with
a change in Mmp2 in any of the genotypes.

The bottom bar plot compares the significance
(-log10(p)) for the forward and reverse interaction across 
genotype. In increase in Mmp2 is significantly associated
with Usp8 expression in the FC and VS animals. However,
an increase in Usp8 is not significantly associated with 
Mmp2 expression in any genotype.

Mmp2 (matrix metallopeptidase 2) enables metalloendopeptidase 
activity and is involved in the response to amyloid beta. Usp8 
(ubiquitin specific peptidates 8) enables cysteine-type 
deubiquitinase activity and is involved in endosome organization 
and protein deubiquitination.

```{r dir_test, fig.width = 11, fig.height = 6}
stop()
#gene1  <- "App"; gene2 <- "Apoe" #example of bi-directional interaction
gene1 <- "Mmp2"; gene2 <- "Usp8" #example of one-way interaction
#gene1  <- "Apoe"; gene2 <- "App"
#gene1  <- "Srsf5"; gene2 <- "Adra1a"

#gene_vioplot(gene1)
#gene_vioplot(gene2, stat.y = 0.2)
#gene_vioplot(gene2, stat.y = 0.9)

#quartz(width = 8, height = 6); stats <- plot_one_interaction(gene1, gene2, report = "cor.test")
#quartz(width = 8, height = 6);plot_directionality(gene1, gene2)
#quartz(width = 11, height = 6)
directed_residuals(gene1, gene2, cex.lab = 1.5)

#quartz(width = 5, height = 7.5)
directed_residuals(gene1, gene2, plot.results = FALSE, plot.predictions = TRUE, cex.lab = 1.5)

#quartz(width = 6, height = 7)
directed_residuals(gene1, gene2, plot.results = FALSE, plot.geno.effect = TRUE, 
    stat.y = 0.2, cex.lab = 1.2)

test.gene <- "Srsf5"
srsf5.conn <- direct_connect(dir.net, test.gene)
u_conn <- unique(names(srsf5.conn))
conn.id <- mouse.genes[match(u_conn, mouse.genes[,"external_gene_name"]),"ensembl_gene_id"]
#cat(conn.id, sep = "\n")

srsf5.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == test.gene),"ensembl_gene_id"]
high.idx <- which(adj_expr[,srsf5.id] > mean(adj_expr[,srsf5.id]))
low.idx <- which(adj_expr[,srsf5.id] < mean(adj_expr[,srsf5.id]))

high.expr <- sapply(conn.id, function(x) coef(lm(adj_expr[high.idx,x]~test.factor[high.idx]))[2])
low.expr <- sapply(conn.id, function(x) coef(lm(adj_expr[low.idx,x]~test.factor[low.idx]))[2])
names(high.expr) <- names(low.expr) <- u_conn
response.mat <- cbind(low.expr, high.expr)
row.order <- hclust(dist(response.mat))$order
colnames(response.mat) <- paste(c("low", "high"), test.gene)
pheatmap(response.mat[row.order,], cluster_cols = FALSE, cluster_rows = FALSE)

straight.cor <- sapply(conn.id, function(x) cor(adj_expr[,x], adj_expr[,srsf5.id]))
imageWithTextColorbar(response.mat, use.pheatmap.colors = TRUE, cex = 1, bar.lwd = 3)

up.with.kl <- which(low.expr > 0)
down.with.kl <- which(low.expr < 0)
#cat(names(up.with.kl), sep = "\n")
#cat(names(down.with.kl), sep = "\n")

```

```{r lookup_genes, eval = FALSE}
#try looking up some of the connector genes in relation to 
#various topics
library(easyPubMed)

#search_string <- "App"
search_string <- c("App", "glutamatergic", "Klotho", "Alzheimer", "proteasome")

hit_mat <- matrix(0, nrow = (length(u_conn)+1), ncol = length(search_string))
rownames(hit_mat) <- c("Srsf5", u_conn)
colnames(hit_mat) <- search_string

pdf("~/Desktop/term_search.pdf")
for(i in 1:length(search_string)){
    all.pubmed <- lapply(c("Srsf5", u_conn), function(x) get_pubmed_ids(paste(search_string[i], "AND", x)))
    num.articles <- as.numeric(sapply(all.pubmed, function(x) x$Count))
    names(num.articles)  <- c("Srsf5", u_conn)
    hit_mat[,i] <- num.articles
    barplot(tail(sort(num.articles, decreasing = FALSE), 25), las = 2, horiz = TRUE, 
        main = search_string[i])
    #abstracts <- fetch_pubmed_data(all.pubmed, format = "medline")
}
dev.off()

has.hits <- which(rowSums(hit_mat) > 0)
pheatmap(log10(hit_mat[has.hits,]+1))

hit.list <- lapply(1:ncol(hit_mat), function(x) names(which(hit_mat[,x] > 0)))
names(hit.list) <- search_string
plotVenn(hit.list)
Reduce("intersect", hit.list)

test.gene <- "Thy1"
complex.search.term <- paste0(test.gene, " AND (", paste(search_string[1:3], collapse = " OR "), ")")
all.pubmed <- get_pubmed_ids(complex.search.term)
all.pubmed$Count


```

I've checked quite a few of these, and the directionality
of the interactions doesn't seem to be terribly useful.
There are some interactions, like the Mmp2-Usp8 one that,
really do seem to be directional, but many of them have
similar interaction profiles going forward and backward,
but the significance of those interaction is on one side
of our threshold or the other.

Thus, genotype really does affect the relationship, but
that influence isn't really directed. So I think the
network itself is interesting, but I think we should
look at it as an undirected network.

### Network hubs

The barplot below shows the top 20 genes in the network
in terms of degree. 

```{r degree, fig.width = 7, fig.height = 15}
deg <- degree(dir.net)

show.n <- min(c(20, length(deg)))
top.deg <- rev(sort(deg, decreasing = TRUE)[1:show.n])
in_ad <- which(!is.na(match(names(top.deg), ad.genes[,1])))
#top.deg[in_ad]
```

The degree by frequency of each degree is shown below on a log-log
scale. This network is pretty modular. There are many nodes with 
degree 1, and there is a heavy tail of high-degree nodes.

```{r deg_freq}
deg.freq <- sapply(1:max(deg), function(x) length(which(deg == x)))
no.zero <- which(deg.freq > 0)
plot(c(1:max(deg))[no.zero], deg.freq[no.zero], log = "xy", xlab = "Degree", ylab = "Frequency")
```


### Correlations by carrier status {.tabset .tabset-fade .tabset-pills}

The following plots show the correlation networks for significant
edges in the two genotypes (FC carriers and VS carriers.) 

The FC and VS carriers have strong correlations in different parts
of the network.

```{r diff_net, fig.width = 10, fig.height = 10, results = "asis"}

#pdf("~/Desktop/geno_nets.pdf", width = 20, height = 20)
geno.nets <- net_by_geno(int_result = corr_result, p.thresh = net.thresh, 
    plot.result = TRUE, layout.mat = net.layout, title.level = "####")
#dev.off()
```

### Edge weight comparison

The plot below shows that the correlations between genes tend to
oppose each other in the two genotypes. Is this just an artifact
of the way we are doing the test? It might be. Let's not put too
much into this.

```{r edge_comparison}
plot(E(geno.nets$FC_net)$weight, E(geno.nets$VS_net)$weight, xlab = "FC edge weights",
    ylab = "VS edge weights")
abline(v = 0, h = 0)
```

### The large connected component

The following plot shows the functional enrichment for the genes
in the large connected component. It is mostly the same as the 
differential expression: synapse and ribosome.

```{r large_enrich}
large.comp <- largest_component(dir.net)
large.enrich <- gost(V(large.comp)$name, organism = "mmusculus")
plot.enrichment(large.enrich, num.terms = 30, max.term.size = 3000,
    plot.label = "Connected Component Enrichment")
```

Below we explore this large connected component more.
The connected component is highly modular. 

The plot below shows just the large connected component
with the top 20 hubs highlighted.

```{r large_comp, fig.width = 20, fig.height = 20}

large.name <- V(large.comp)$name
comp.layout <- net.layout[match(large.name, rownames(net.layout)),]

#plot the large component alone and with the top 20 hubs labeled
#pdf("~/Desktop/large_comp.pdf", width = 20, height = 20)
#plot_net(large.comp, layout.mat = comp.layout)
plot_net(large.comp, layout.mat = comp.layout, highlight.nodes = names(top.deg),
    highlight.width = 0.05, highlight.height = 0.02, highlight.cex = 1.5,
    highlight.lwd = 3)
#dev.off()
```

### Differential expression in the large connected component

The plot below shows the expression results for the genes
in the large connected component.

```{r, fig.width = 11, fig.height = 7}
#diff expp

#png("~/Desktop/large_expression.png", width = 11, height = 7, units = "in", res = 300)
large.id <- mouse.genes[match(large.name, mouse.genes[,"external_gene_name"]), "ensembl_gene_id"]
large.stats <- plot_individual_genes(gene.list = large.id, order.by = "PC", 
    plot.label = "Large Connected Component", return.full.result = TRUE, plot.enrich = TRUE)
#dev.off()
```

The plot below shows the relative VS expression for each gene
in this connected component. Brown means that the gene is 
upregulated in VS animals. Blue means it is downregulated in
VS animals. There is no obvious pattern.

```{r relative_expr, fig.width = 20, fig.height = 20}

#weight the nodes based on relative VS expression
large.expr <- lapply(large.name, function(x) gene_vioplot(x, plot.results = FALSE))
large.mean <- t(sapply(large.expr, function(x) sapply(x, mean)))
rel.vs <- large.mean[,3] - large.mean[,1]
V(large.comp)$weight <- rel.vs

#pdf("~/Desktop/large_comp_vertex.pdf", width = 20, height = 20)
plot_net(large.comp, layout.mat = comp.layout, vertex.size = 5, edge.width.factor = 1,
    highlight.nodes = names(top.deg), highlight.width = 0.05, highlight.height = 0.02, 
    highlight.cex = 1.5)
#dev.off()
```

### Biodomains and KEGG pathways in the large connected component

How are the biodomains and KEGG pathways distributed in this component?
The bar plots below show the -log10(p) for the enrichments of each 
biodomain, and the top 20 KEGG pathways, in the large connected
component.

Ribosome and proteostasis really shine through.

```{r biodomain_enrich, fig.width = 10, fig.height = 7}
bd.enrich.p <- sapply(bd.list, function(x) gene_set_enrich(x, large.id, test.id))
par(mar = c(4,16,4,2))
barplot(sort(-log10(bd.enrich.p)), las = 2, horiz = TRUE, xlab = "-log10(p)",
    main = "Biodomains enriched in large connected component")

kegg.enrich.p <- sapply(kegg.list, function(x) gene_set_enrich(x, large.id, test.id))
par(mar = c(4,24,4,2))
barplot(rev(sort(-log10(kegg.enrich.p), decreasing = TRUE)[1:20]), las = 2, horiz = TRUE, xlab = "-log10(p)",
    main = "KEGG pathways enriched in\nlarge connected component")
```

What about localization in the network? How spread out 
are these nodes? Does that matter?

I selected 5000 random samples of genes using the number of 
genes in the biodomains. I got a distribution of node sizes 
and average node distances for each group. There are a couple 
domains in Proteostasis and Structural Stabilization that have
lower distances relative to their size than the random distribution.
They are in Ribosome and COVID (read virus response?) KEGG pathways.

So Ribosome genes and COVID (virus response genes?) are closer
to each other in this network than we expect by chance. Not 
particularly interesting...

```{r node_clustering, eval = FALSE}

get_list_dist <- function(net, gene.list, plot.results = TRUE){
    edges <- as_edgelist(net) #we need to remove the weights from the network
    flat.net <- graph_from_edgelist(edges, directed = FALSE)
    node.dist <- distances(flat.net)

    gene.name <- lapply(gene.list, function(x) mouse.genes[match(x, mouse.genes[,"ensembl_gene_id"]), "external_gene_name"])
    common.name <- lapply(gene.name, function(x) intersect(V(flat.net)$name, x))
    common.dist <- lapply(common.name, function(x) node.dist[x,x])
    avg.dist <- sapply(common.dist, mean)
    
    if(plot.results){
        par(mfrow = c(1,2), mar = c(4,12,4,2))
        barplot(sort(avg.dist, decreasing = TRUE), las = 2, horiz = TRUE)

        par(mar = c(4,4,4,2))
        n.nodes <- sapply(common.name, length)
        plot(n.nodes, avg.dist)
        #boxplot(lapply(bd.dist, function(x) x[upper.tri(x, diag = FALSE)]), las = 2)
    }
    invisible(common.dist)
}

bd.list.len <- sapply(bd.list, length)
rnd_sample <- lapply(1:5000, function(x) sample(unique(unlist(bd.list)), sample(bd.list.len, 1))) #pull some random samples from the biodomainlist
rnd_cl <- get_list_dist(large.comp, rnd_sample, plot.results = FALSE)
rnd.dist <- sapply(rnd_cl, mean)
rnd.nodes <- sapply(rnd_cl, function(x) if(class(x)[1] == "matrix"){nrow(x)}else{0})
#plot(rnd.nodes, rnd.dist) #the randomly sampled cluster sizes and distances in the large component
#plot.hexbin.as.plot(rnd.nodes, rnd.dist)

pdf("~/Desktop/cl_test.pdf", width = 5, height = 5)
for(bd in 1:length(kegg.bd.list)){
    if(length(kegg.bd.list[[bd]]) > 0){
        test <- get_list_dist(large.comp, kegg.bd.list[[bd]], plot.results = FALSE)
        test.dist <- sapply(test, mean)
        test.nodes <- sapply(test, function(x) if(class(x)[1] == "matrix"){nrow(x)}else{0})
        plot.hexbin.as.plot(rnd.nodes, rnd.dist, main = names(kegg.bd.list)[bd], xlim = c(0, 200))
        points(test.nodes, test.dist, pch = 16)

        #check <- intersect(which(test.nodes > 25), which(test.dist < 4))
        #names(kegg.bd.list[[bd]])[check]
    }
}
dev.off()
```

 
The biodomain-KEGG intersections that were significantly
enriched in the large connected component are the following.
Purple vertices show biodomains, green show Kegg pathways.
Edge color and width reflect the -log10(p) of the enrichment.

```{r enrich_int, fig.width = 7, fig.height = 7}
enrich.p.mat <- matrix(NA, nrow = length(bd.list), ncol = length(kegg.list))
rownames(enrich.p.mat) <- names(bd.list)
colnames(enrich.p.mat) <- names(kegg.list)
for(bd in 1:length(kegg.bd.list)){
    bd.name <- names(kegg.bd.list)[bd]
    if(length(kegg.bd.list[[bd]]) == 0){next()}
    for(k in 1:length(kegg.bd.list[[bd]])){
        kegg.name <- names(kegg.bd.list[[bd]])[k]
        test.set <- kegg.bd.list[[bd]][[k]]
        sub.enrich <- gene_set_enrich(test.set, large.id, test.id)
        enrich.p.mat[bd.name, kegg.name] <- sub.enrich
    }
}
sig.enrich <- which(enrich.p.mat <= 1e-5, arr.ind = TRUE)
int.enrich <- cbind(rownames(enrich.p.mat)[sig.enrich[,1]], colnames(enrich.p.mat)[sig.enrich[,2]])
test <- graph_from_edgelist(int.enrich, directed = FALSE)
ecol <- colors.from.values(-log10(enrich.p.mat[sig.enrich]), col.scale = "blue", grad.dir = "high")
vcol <- rep("#7FC97F", vcount(test)) #kegg color
vcol[which(V(test)$name %in% names(bd.list))] <- "#beaed4" #biodomain color

par(mar = c(0,8,0,6))
plot(test, vertex.color = vcol, edge.color = ecol, edge.width = -log10(enrich.p.mat[sig.enrich])/2)

#imageWithTextColorbar(matrix(-log10(enrich.p.mat[sig.enrich]), ncol = 1), col.scale = "blue", 
#    grad.dir = "high", cex = 1, bar.lwd = 2)
```

### Enrichments Localized {.tabset .tabset-fade .tabset-pills}

The following plots show where these intersections lie in the 
network.

```{r enrich_net, fig.width = 20, fig.height = 20, results = "asis"}
#pdf("~/Desktop/enriched_intersections.pdf", width = 20, height = 20)
for(i in 1:nrow(int.enrich)){
    bd.name <- int.enrich[i,1]
    bd.idx <- which(names(kegg.bd.list) == bd.name)
    kegg.name <- int.enrich[i,2]
    kegg.idx <- which(names(kegg.bd.list[[bd.idx]]) == kegg.name)
    cat("####", bd.name, "-", kegg.name, "\n")

    int.genes <- kegg.bd.list[[bd.idx]][[kegg.idx]]
    int.names <- mouse.genes[match(int.genes, mouse.genes[,"ensembl_gene_id"]),"external_gene_name"]
    common.genes <- intersect(int.names, large.name)

    plot_net(large.comp, layout.mat = comp.layout, vertex.size = 5, edge.width.factor = 5,
    highlight.nodes = common.genes, highlight.width = 0.05, highlight.height = 0.02, 
    highlight.cex = 1.5, plot.label = paste(bd.name, kegg.name, sep = " - "))
    cat("\n\n")
}
#dev.off()
```

### Networks by genotoype {.tabset .tabset-fade .tabset-pills}

The following plots how the genes in the network are differentially
correlated in the VS and FC genotypes.

```{r, results = "asis", fig.width = 20, fig.height = 20}
#geno nets just for connected component
large.idx <- match(large.name, colnames(corr_result[[1]]))
large.result <- lapply(corr_result, function(x) x[large.idx, large.idx])

#pdf("~/Desktop/geno_nets_large.pdf", width = 20, height = 20)
geno.nets <- net_by_geno(int_result = large.result, p.thresh = net.thresh, 
    plot.result = TRUE, layout.mat = net.layout, title.level = "####",
    highlight.nodes = names(top.deg),
    highlight.width = 0.05, highlight.height = 0.02, highlight.cex = 1.5,
    highlight.lwd = 3)

#without labels
geno.nets <- net_by_geno(int_result = large.result, p.thresh = net.thresh, 
    plot.result = TRUE, layout.mat = net.layout, title.level = "####")

#dev.off()

```

### Hub Neighborhoods {.tabset .tabset-fade .tabset-pills}

The following plots show the expression results for the genes
in the neighborhood of each of the top 20 hubs.

```{r connect_enrich, results = "asis", fig.width = 11, fig.height = 7}
#gene.name = "Srsf5"
#gene.name <- c("Mylpf", "Atp2a1", "Tnnc2")
gene.name <- names(top.deg) #top 20 hubs

connected <- lapply(gene.name, function(x) names(direct_connect(dir.net, x)))
#cat(connected, sep = "\n")
connected.id <- lapply(connected, function(x) mouse.genes[match(x, mouse.genes[,"external_gene_name"]), "ensembl_gene_id"])
names(connected.id) <- gene.name
#connect.enrich <- gost(connected[[1]], organism = "mmusculus")
#plot.enrichment(connect.enrich, max.term.size = 3000, num.terms = 20, plot.label = gene.name)


for(i in 1:length(gene.name)){
    cat("####", gene.name[i], "\n")
    hub.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] == gene.name[i]),"ensembl_gene_id"]
    #png(paste0("~/Desktop/hub_neighborhoods/", gene.name[i], ".png"), width = 11, height = 7, units = "in", res = 300)
    gene.stats <- plot_individual_genes(gene.list = c(hub.id, connected.id[[i]]), 
        plot.label = paste("genes connected to", gene.name[i]), plot.enrich = TRUE,
        return.full.result = TRUE)
    #test <- gost(c(hub.id, connected.id[[i]]), organism = "mmusculus")
    #plot.enrichment(test)
    #dev.off()
    cat("\n\n")
}
cat("#### All connected genes")
all.connected <- unique(unlist(connected.id))
#png(paste0("~/Desktop/all_connected.png"), width = 11, height = 7, units = "in", res = 300)
plot_individual_genes(gene.list = all.connected, 
    plot.label = "genes connected to all genes", plot.enrich = TRUE)
cat("\n\n")
#dev.off()


```

### Remaining analysis

```{r ind_terms, eval = FALSE}
#here we plot violin plots of specific terms we are interested in.

pdf("~/Desktop/mapk.pdf", width = 7, height = 5)
term_vioplot(outer.term = "MAPK signaling pathway", inner.term = "Apoptosis", 
    mean.term.vals = mean.bd.k.vals)

term_vioplot(outer.term = "MAPK signaling pathway", inner.term = "DNA Repair", 
    mean.term.vals = mean.bd.k.vals, stat.y = 0.95, autoflip.stat.y = FALSE)
dev.off()

term_vioplot(outer.term = "Type II diabetes mellitus", mean.term.vals = mean.k.vals)
term_vioplot(outer.term = "Proteasome", mean.term.vals = mean.k.vals, stat.y = 0.95)
```



```{r ind_gene, eval = FALSE}
#This block look for gene sets and plots their expression
#and decomposition by individual

#search.term <- c("Itga", "Itgb")
#search.term <- c("Fgf")
#search.term = "Grin"
search.term = "Mapk"

plot.genes <- unlist(lapply(search.term, function(x) mouse.genes[grep(x, mouse.genes[,"external_gene_name"]),"external_gene_name"]))
length(plot.genes)

gene.id <- mouse.genes[which(mouse.genes[,"external_gene_name"] %in% plot.genes),"ensembl_gene_id"]
common.genes <- intersect(colnames(adj_expr), gene.id)
names(common.genes) <- mouse.genes[match(common.genes, mouse.genes[,"ensembl_gene_id"]),"external_gene_name"]
gene.expr <- lapply(geno.idx, function(x) adj_expr[x,common.genes])
plot_individual_genes(gene.list = common.genes, order.by = "PC", plot.label = "Mapk")


for(i in 1:length(gene.expr)){
    colnames(gene.expr[[i]]) <- names(common.genes)
}
plot.grouped.boxes(gene.expr, type = "matrix", group.cols = geno.cols, main = search.term,
    print.vals = NA)
plot.dim <- par("usr")
segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = 0)
```


```{r, eval = FALSE}
#This block looks at correlations between genes in 
#a given intersection
int.genes <- plot_individual_genes(intersection.name = "ECM-receptor interaction : Synapse")
int.names <- mouse.genes[match(int.genes, mouse.genes[,"ensembl_gene_id"]),"external_gene_name"]
int.expr <- adj_expr[,int.genes]
colnames(int.expr) <- int.names
imageWithText(signif(cor(int.expr), 2), use.pheatmap.colors = TRUE)


term.name = "Ribosome"
term.idx <- which(names(kegg.list) == term.name)
plot_individual_genes(gene.list = kegg.list[[term.idx]], 
    plot.type = "individual", plot.label = term.name, label.margin = 4)


kegg.vals <- non_nested_mean_vals(non_nested_gene_list = kegg.list, adj_expr, 
    group.representation = group.representation)
kegg.result <- plot_mean_bd_k(kegg.vals, covar.mat = covar.table, plot.label = "KEGG")
kegg.r2 <- kegg.result$row.r2

par(mar = c(4,22,2,2))
barplot(tail(sort(kegg.r2), 20), las = 2, horiz = TRUE)
```

```{r connection_enrich, eval = FALSE}
#this block looks at enrichments of particular interactions
#in the KEGG-Biodomain network

term.name <- "ECM-receptor interaction : Synapse"
term.name <- "Cell adhesion molecules : Synapse"
term.name <- "Type II diabetes mellitus : Synapse"
term.name <- "Parkinson disease : DNA Repair"
term.name <- "Ras signaling pathway : APP Metabolism"
int.genes <- plot_individual_genes(intersection.name = term.name)
int.enrich <- gost(int.genes, organism = "mmusculus", sources = c("GO", "KEGG", "REACTOME", "HP", "CORUM"))
plot.enrichment(int.enrich, max.term.size = 3000, num.terms = 30, plot.label = term.name)

```

